---
title: "地面检测"
date: "2026-01-30"
tags: [Unity, 物理检测, 地面检测, Raycast]
---

# 地面检测

## 问题描述
Unity中如何实现地面检测？有哪些常用的检测方法？

## 回答

### 1. 问题分析

**技术背景**：
- 地面检测是角色控制器中的核心功能，用于判断角色是否与地面接触
- 在Unity中，有多种方法可以实现地面检测，每种方法都有其适用场景
- 选择合适的地面检测方法对游戏体验和性能都有重要影响

**根本原因**：
- 不同游戏场景对地面检测的要求不同（如平坦地面 vs 斜坡）
- 不同检测方法的性能开销和准确性存在差异
- 需要根据具体游戏类型和平台性能选择合适的检测方案

**解决方案概述**：
- 了解各种地面检测方法的原理和特点
- 根据游戏场景选择合适的检测方法
- 实现优化的地面检测系统，确保准确性和性能

### 2. 案例演示

#### 2.1 Raycast射线检测（最常用）

```csharp
using UnityEngine;

public class GroundCheck_Raycast : MonoBehaviour
{
    [Header("地面检测设置")]
    [SerializeField] private float rayLength = 0.6f;        // 射线长度
    [SerializeField] private float rayOffset = 0.1f;        // 射线起始点偏移
    [SerializeField] private LayerMask groundLayer;         // 地面层级
    
    [Header("调试")]
    [SerializeField] private bool showDebugRay = true;      // 显示调试射线
    
    public bool IsGrounded { get; private set; }
    public RaycastHit GroundHitInfo { get; private set; }
    
    private void Update()
    {
        CheckGround();
    }
    
    private void CheckGround()
    {
        // 射线起始点（角色底部稍微向上偏移）
        Vector3 rayOrigin = transform.position + Vector3.up * rayOffset;
        
        // 向下发射射线
        Ray ray = new Ray(rayOrigin, Vector3.down);
        RaycastHit hit;
        
        IsGrounded = Physics.Raycast(ray, out hit, rayLength, groundLayer);
        GroundHitInfo = hit;
        
        // 调试显示
        if (showDebugRay)
        {
            Color rayColor = IsGrounded ? Color.green : Color.red;
            Debug.DrawRay(rayOrigin, Vector3.down * rayLength, rayColor);
        }
    }
}
```

#### 2.2 多射线检测（更稳定）

```csharp
using UnityEngine;

public class GroundCheck_MultiRaycast : MonoBehaviour
{
    [Header("多射线检测设置")]
    [SerializeField] private float rayLength = 0.6f;
    [SerializeField] private float rayOffset = 0.1f;
    [SerializeField] private float raySpread = 0.3f;        // 射线横向间距
    [SerializeField] private LayerMask groundLayer;
    
    [Header("斜坡检测")]
    [SerializeField] private float maxSlopeAngle = 45f;     // 最大可行走坡度
    
    public bool IsGrounded { get; private set; }
    public float GroundSlopeAngle { get; private set; }     // 地面坡度
    public Vector3 GroundNormal { get; private set; }       // 地面法线
    
    private void Update()
    {
        CheckGroundWithMultipleRays();
    }
    
    private void CheckGroundWithMultipleRays()
    {
        // 三条射线位置：左、中、右
        Vector3[] rayOrigins = new Vector3[]
        {
            transform.position + Vector3.up * rayOffset + Vector3.left * raySpread,
            transform.position + Vector3.up * rayOffset,
            transform.position + Vector3.up * rayOffset + Vector3.right * raySpread
        };
        
        IsGrounded = false;
        GroundSlopeAngle = 0f;
        
        foreach (var origin in rayOrigins)
        {
            RaycastHit hit;
            if (Physics.Raycast(origin, Vector3.down, out hit, rayLength, groundLayer))
            {
                // 计算坡度
                float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                
                // 如果坡度可接受
                if (slopeAngle <= maxSlopeAngle)
                {
                    IsGrounded = true;
                    GroundSlopeAngle = slopeAngle;
                    GroundNormal = hit.normal;
                    
                    // 绘制调试射线
                    Debug.DrawRay(origin, Vector3.down * rayLength, Color.green);
                    Debug.DrawRay(hit.point, hit.normal * 0.5f, Color.blue);
                }
                else
                {
                    Debug.DrawRay(origin, Vector3.down * rayLength, Color.yellow);
                }
            }
            else
            {
                Debug.DrawRay(origin, Vector3.down * rayLength, Color.red);
            }
        }
    }
}
```

#### 2.3 OverlapCircle检测（2D游戏推荐）

```csharp
using UnityEngine;

public class GroundCheck_Overlap2D : MonoBehaviour
{
    [Header("圆形重叠检测设置")]
    [SerializeField] private float checkRadius = 0.3f;      // 检测半径
    [SerializeField] private Vector2 checkOffset;           // 检测偏移
    [SerializeField] private LayerMask groundLayer;
    
    [Header("可选：显示检测区域")]
    [SerializeField] private bool showGizmo = true;
    
    public bool IsGrounded { get; private set; }
    public Collider2D[] GroundColliders { get; private set; }
    
    private void Update()
    {
        CheckGroundOverlap();
    }
    
    private void CheckGroundOverlap()
    {
        // 检测位置
        Vector2 checkPosition = (Vector2)transform.position + checkOffset;
        
        // 圆形重叠检测
        GroundColliders = Physics2D.OverlapCircleAll(checkPosition, checkRadius, groundLayer);
        IsGrounded = GroundColliders.Length > 0;
    }
    
    private void OnDrawGizmos()
    {
        if (!showGizmo) return;
        
        Vector2 checkPosition = (Vector2)transform.position + checkOffset;
        Gizmos.color = IsGrounded ? Color.green : Color.red;
        Gizmos.DrawWireSphere(checkPosition, checkRadius);
    }
}
```

#### 2.4 完整角色控制器示例

```csharp
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class PlayerController : MonoBehaviour
{
    [Header("移动设置")]
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float jumpForce = 8f;
    
    [Header("地面检测")]
    [SerializeField] private float groundCheckDistance = 0.6f;
    [SerializeField] private float groundCheckOffset = 0.1f;
    [SerializeField] private float groundCheckRadius = 0.3f;
    [SerializeField] private LayerMask groundLayer;
    [SerializeField] private GroundCheckMethod checkMethod = GroundCheckMethod.Raycast;
    
    [Header("斜坡设置")]
    [SerializeField] private float maxSlopeAngle = 45f;
    [SerializeField] private bool slideOnSteepSlope = true;
    
    private Rigidbody rb;
    private bool isGrounded;
    private Vector3 groundNormal;
    private float groundSlopeAngle;
    
    private enum GroundCheckMethod
    {
        Raycast,
        SphereCast,
        BoxCast,
        OverlapSphere
    }
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.freezeRotation = true;
    }
    
    private void Update()
    {
        // 检测地面
        CheckGround();
        
        // 处理输入
        HandleInput();
        
        // 应用斜坡移动
        if (isGrounded && slideOnSteepSlope && groundSlopeAngle > maxSlopeAngle)
        {
            ApplySlide();
        }
    }
    
    private void FixedUpdate()
    {
        HandleMovement();
    }
    
    private void CheckGround()
    {
        Vector3 checkOrigin = transform.position + Vector3.up * groundCheckOffset;
        
        switch (checkMethod)
        {
            case GroundCheckMethod.Raycast:
                CheckGroundRaycast(checkOrigin);
                break;
            case GroundCheckMethod.SphereCast:
                CheckGroundSphereCast(checkOrigin);
                break;
            case GroundCheckMethod.BoxCast:
                CheckGroundBoxCast(checkOrigin);
                break;
            case GroundCheckMethod.OverlapSphere:
                CheckGroundOverlapSphere(checkOrigin);
                break;
        }
    }
    
    private void CheckGroundRaycast(Vector3 origin)
    {
        RaycastHit hit;
        isGrounded = Physics.Raycast(origin, Vector3.down, out hit, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundSphereCast(Vector3 origin)
    {
        RaycastHit hit;
        isGrounded = Physics.SphereCast(origin, groundCheckRadius, Vector3.down, 
            out hit, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundBoxCast(Vector3 origin)
    {
        Vector3 halfExtents = new Vector3(groundCheckRadius, 0.05f, groundCheckRadius);
        RaycastHit hit;
        isGrounded = Physics.BoxCast(origin, halfExtents, Vector3.down, 
            out hit, Quaternion.identity, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundOverlapSphere(Vector3 origin)
    {
        Collider[] colliders = Physics.OverlapSphere(origin, groundCheckRadius, groundLayer);
        isGrounded = colliders.Length > 0;
        
        if (isGrounded && colliders.Length > 0)
        {
            // 获取最近的地面法线
            groundNormal = Vector3.up;
            groundSlopeAngle = 0f;
        }
    }
    
    private void HandleInput()
    {
        // 跳跃
        if (isGrounded && Input.GetButtonDown("Jump"))
        {
            Jump();
        }
    }
    
    private void HandleMovement()
    {
        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");
        
        Vector3 moveDirection = new Vector3(horizontal, 0, vertical).normalized;
        
        // 在斜坡上调整移动方向
        if (isGrounded && groundSlopeAngle > 0 && groundSlopeAngle <= maxSlopeAngle)
        {
            moveDirection = Vector3.ProjectOnPlane(moveDirection, groundNormal).normalized;
        }
        
        Vector3 targetVelocity = moveDirection * moveSpeed;
        targetVelocity.y = rb.velocity.y;
        
        rb.velocity = targetVelocity;
    }
    
    private void Jump()
    {
        rb.velocity = new Vector3(rb.velocity.x, jumpForce, rb.velocity.z);
        isGrounded = false;
    }
    
    private void ApplySlide()
    {
        // 在陡坡上滑行
        Vector3 slideDirection = Vector3.ProjectOnPlane(Vector3.down, groundNormal).normalized;
        rb.AddForce(slideDirection * 10f, ForceMode.Acceleration);
    }
    
    private void OnDrawGizmos()
    {
        Vector3 origin = transform.position + Vector3.up * groundCheckOffset;
        
        // 绘制检测范围
        Gizmos.color = isGrounded ? Color.green : Color.red;
        
        switch (checkMethod)
        {
            case GroundCheckMethod.Raycast:
                Gizmos.DrawLine(origin, origin + Vector3.down * groundCheckDistance);
                break;
            case GroundCheckMethod.SphereCast:
                Gizmos.DrawWireSphere(origin + Vector3.down * groundCheckDistance, groundCheckRadius);
                break;
            case GroundCheckMethod.BoxCast:
                Gizmos.DrawWireCube(origin + Vector3.down * groundCheckDistance, 
                    new Vector3(groundCheckRadius * 2, 0.1f, groundCheckRadius * 2));
                break;
            case GroundCheckMethod.OverlapSphere:
                Gizmos.DrawWireSphere(origin, groundCheckRadius);
                break;
        }
        
        // 绘制地面法线
        if (isGrounded)
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawRay(transform.position, groundNormal * 0.5f);
        }
    }
}
```

### 3. 注意事项

#### 3.1 常用检测方法对比

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Raycast（射线检测） | 简单高效 | 只能检测单点，容易误判 | 平坦地面 |
| OverlapCircle/Sphere（圆形/球形重叠） | 检测范围大，更稳定 | 稍耗性能 | 斜坡、不规则地面 |
| BoxCast（盒形投射） | 检测区域精确 | 配置较复杂 | 平台边缘检测 |
| 碰撞器事件 | 物理准确 | 有延迟，需要刚体 | 复杂物理交互 |

#### 3.2 常见问题与解决方案

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| **跳跃后无法再次跳跃** | 地面检测过于敏感，跳跃瞬间仍检测到地面 | 添加跳跃冷却时间或使用协程延迟检测 |
| **斜坡上下抖动** | 射线检测在斜坡上会误判距离 | 使用SphereCast或调整检测位置 |
| **平台边缘误判** | 单点检测在边缘不稳定 | 使用多射线或BoxCast检测 |
| **高速穿过地面** | 物体速度过快，检测间隔内穿过地面 | 使用Continuous碰撞检测或增加检测频率 |

#### 3.3 性能优化建议

```csharp
public class GroundCheckOptimized : MonoBehaviour
{
    [Header("优化设置")]
    [SerializeField] private int checkInterval = 3;     // 每3帧检测一次
    [SerializeField] private bool useNonAlloc = true;   // 使用非分配版本
    
    private Collider[] results = new Collider[5];       // 预分配数组
    private int frameCounter = 0;
    private bool isGrounded;
    private LayerMask groundLayer;
    
    private void Update()
    {
        frameCounter++;
        if (frameCounter % checkInterval == 0)
        {
            CheckGroundOptimized();
        }
    }
    
    private void CheckGroundOptimized()
    {
        if (useNonAlloc)
        {
            // 使用非分配版本，避免GC
            int count = Physics.OverlapSphereNonAlloc(
                transform.position, 0.3f, results, groundLayer);
            isGrounded = count > 0;
        }
        else
        {
            // 标准版本会产生垃圾回收
            isGrounded = Physics.OverlapSphere(transform.position, 0.3f, groundLayer).Length > 0;
        }
    }
}
```

#### 3.4 最佳实践

1. **层级设置**：为地面设置专门的Layer，使用LayerMask提高检测效率
2. **调试可视化**：始终使用Gizmos或Debug.DrawRay可视化检测范围
3. **多方法结合**：复杂地形可结合多种检测方法
4. **缓存结果**：避免每帧重复计算，可缓存检测结果
5. **考虑边缘情况**：处理斜坡、移动平台、单向平台等特殊情况
6. **跳跃缓冲**：实现Coyote Time，提升游戏体验

```csharp
[SerializeField] private float coyoteTime = 0.1f;   // 离开地面后仍可跳跃的时间
private float coyoteTimeCounter;

private void Update()
{
    if (isGrounded)
    {
        coyoteTimeCounter = coyoteTime;
    }
    else
    {
        coyoteTimeCounter -= Time.deltaTime;
    }
    
    // 跳跃条件包含coyoteTime
    if ((isGrounded || coyoteTimeCounter > 0) && Input.GetButtonDown("Jump"))
    {
        Jump();
    }
}
```

### 4. 实现原理

**底层实现**：
- **Raycast**：从指定点沿指定方向发射射线，检测与碰撞体的交点
- **OverlapSphere**：检测指定球形区域内的所有碰撞体
- **BoxCast**：将盒形区域沿指定方向投射，检测与碰撞体的交点
- **碰撞器事件**：通过MonoBehaviour的碰撞事件方法（如OnCollisionEnter）检测碰撞

**Unity引擎分析**：
- **Physics.Raycast**：调用底层物理引擎的射线检测功能
- **LayerMask**：使用位掩码提高检测效率，只检测指定层级
- **Gizmos**：Unity编辑器中的可视化工具，用于调试

**核心执行流程**：
1. **初始化**：设置检测参数（如射线长度、检测半径等）
2. **执行检测**：调用相应的物理检测方法
3. **处理结果**：根据检测结果更新地面状态
4. **应用逻辑**：根据地面状态执行相应的游戏逻辑（如跳跃）

### 5. 结论

地面检测是Unity游戏开发中不可或缺的功能，它直接影响角色控制的手感和游戏体验。选择合适的地面检测方法需要考虑以下因素：

- **游戏类型**：2D游戏 vs 3D游戏，平台游戏 vs 开放世界游戏
- **地形复杂度**：平坦地面 vs 复杂斜坡
- **性能要求**：移动平台 vs PC平台
- **精度需求**：简单检测 vs 精确检测

通过本文介绍的各种地面检测方法和优化技巧，开发者可以根据具体游戏场景选择最合适的实现方案，打造出流畅、稳定的角色控制系统。

**最佳实践总结**：
1. 优先使用Raycast进行简单地面检测
2. 在复杂地形使用OverlapSphere或多射线检测
3. 对平台边缘检测使用BoxCast
4. 实现Coyote Time提升游戏体验
5. 优化检测频率和使用非分配版本减少GC
6. 始终进行可视化调试，确保检测范围合理

通过合理的地面检测实现，开发者可以为玩家提供更加流畅、自然的游戏控制体验。
