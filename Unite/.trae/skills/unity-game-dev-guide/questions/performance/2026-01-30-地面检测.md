---
title: "地面检测"
date: "2026-01-30"
tags: [Unity, 物理检测, 地面检测, Raycast]
---

# 地面检测

## 问题描述
Unity中如何实现地面检测？有哪些常用的检测方法？

## 回答

### 1. 问题分析

**地面检测的作用**：
- 判断角色是否站在地面上，控制跳跃逻辑
- 防止空中无限跳跃
- 检测角色是否掉落悬崖
- 实现不同的地面材质效果（如脚步声）

**常用检测方法对比**：

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Raycast（射线检测） | 简单高效 | 只能检测单点，容易误判 | 平坦地面 |
| OverlapCircle/Sphere（圆形/球形重叠） | 检测范围大，更稳定 | 稍耗性能 | 斜坡、不规则地面 |
| BoxCast（盒形投射） | 检测区域精确 | 配置较复杂 | 平台边缘检测 |
| 碰撞器事件 | 物理准确 | 有延迟，需要刚体 | 复杂物理交互 |

---

### 2. 案例演示

#### 2.1 Raycast射线检测（最常用）

```csharp
using UnityEngine;

public class GroundCheck_Raycast : MonoBehaviour
{
    [Header("地面检测设置")]
    [SerializeField] private float rayLength = 0.6f;        // 射线长度
    [SerializeField] private float rayOffset = 0.1f;        // 射线起始点偏移
    [SerializeField] private LayerMask groundLayer;         // 地面层级
    
    [Header("调试")]
    [SerializeField] private bool showDebugRay = true;      // 显示调试射线
    
    public bool IsGrounded { get; private set; }
    public RaycastHit GroundHitInfo { get; private set; }
    
    private void Update()
    {
        CheckGround();
    }
    
    private void CheckGround()
    {
        // 射线起始点（角色底部稍微向上偏移）
        Vector3 rayOrigin = transform.position + Vector3.up * rayOffset;
        
        // 向下发射射线
        Ray ray = new Ray(rayOrigin, Vector3.down);
        RaycastHit hit;
        
        IsGrounded = Physics.Raycast(ray, out hit, rayLength, groundLayer);
        GroundHitInfo = hit;
        
        // 调试显示
        if (showDebugRay)
        {
            Color rayColor = IsGrounded ? Color.green : Color.red;
            Debug.DrawRay(rayOrigin, Vector3.down * rayLength, rayColor);
        }
    }
}
```

#### 2.2 多射线检测（更稳定）

```csharp
using UnityEngine;

public class GroundCheck_MultiRaycast : MonoBehaviour
{
    [Header("多射线检测设置")]
    [SerializeField] private float rayLength = 0.6f;
    [SerializeField] private float rayOffset = 0.1f;
    [SerializeField] private float raySpread = 0.3f;        // 射线横向间距
    [SerializeField] private LayerMask groundLayer;
    
    [Header("斜坡检测")]
    [SerializeField] private float maxSlopeAngle = 45f;     // 最大可行走坡度
    
    public bool IsGrounded { get; private set; }
    public float GroundSlopeAngle { get; private set; }     // 地面坡度
    public Vector3 GroundNormal { get; private set; }       // 地面法线
    
    private void Update()
    {
        CheckGroundWithMultipleRays();
    }
    
    private void CheckGroundWithMultipleRays()
    {
        // 三条射线位置：左、中、右
        Vector3[] rayOrigins = new Vector3[]
        {
            transform.position + Vector3.up * rayOffset + Vector3.left * raySpread,
            transform.position + Vector3.up * rayOffset,
            transform.position + Vector3.up * rayOffset + Vector3.right * raySpread
        };
        
        IsGrounded = false;
        GroundSlopeAngle = 0f;
        
        foreach (var origin in rayOrigins)
        {
            RaycastHit hit;
            if (Physics.Raycast(origin, Vector3.down, out hit, rayLength, groundLayer))
            {
                // 计算坡度
                float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                
                // 如果坡度可接受
                if (slopeAngle <= maxSlopeAngle)
                {
                    IsGrounded = true;
                    GroundSlopeAngle = slopeAngle;
                    GroundNormal = hit.normal;
                    
                    // 绘制调试射线
                    Debug.DrawRay(origin, Vector3.down * rayLength, Color.green);
                    Debug.DrawRay(hit.point, hit.normal * 0.5f, Color.blue);
                }
                else
                {
                    Debug.DrawRay(origin, Vector3.down * rayLength, Color.yellow);
                }
            }
            else
            {
                Debug.DrawRay(origin, Vector3.down * rayLength, Color.red);
            }
        }
    }
}
```

#### 2.3 OverlapCircle检测（2D游戏推荐）

```csharp
using UnityEngine;

public class GroundCheck_Overlap2D : MonoBehaviour
{
    [Header("圆形重叠检测设置")]
    [SerializeField] private float checkRadius = 0.3f;      // 检测半径
    [SerializeField] private Vector2 checkOffset;           // 检测偏移
    [SerializeField] private LayerMask groundLayer;
    
    [Header("可选：显示检测区域")]
    [SerializeField] private bool showGizmo = true;
    
    public bool IsGrounded { get; private set; }
    public Collider2D[] GroundColliders { get; private set; }
    
    private void Update()
    {
        CheckGroundOverlap();
    }
    
    private void CheckGroundOverlap()
    {
        // 检测位置
        Vector2 checkPosition = (Vector2)transform.position + checkOffset;
        
        // 圆形重叠检测
        GroundColliders = Physics2D.OverlapCircleAll(checkPosition, checkRadius, groundLayer);
        IsGrounded = GroundColliders.Length > 0;
    }
    
    private void OnDrawGizmos()
    {
        if (!showGizmo) return;
        
        Vector2 checkPosition = (Vector2)transform.position + checkOffset;
        Gizmos.color = IsGrounded ? Color.green : Color.red;
        Gizmos.DrawWireSphere(checkPosition, checkRadius);
    }
}
```

#### 2.4 BoxCast检测（3D平台游戏）

```csharp
using UnityEngine;

public class GroundCheck_BoxCast : MonoBehaviour
{
    [Header("盒形投射设置")]
    [SerializeField] private Vector3 boxSize = new Vector3(0.8f, 0.1f, 0.8f);
    [SerializeField] private float castDistance = 0.5f;
    [SerializeField] private float castOffset = 0.1f;
    [SerializeField] private LayerMask groundLayer;
    
    public bool IsGrounded { get; private set; }
    public RaycastHit GroundHit { get; private set; }
    
    private void Update()
    {
        CheckGroundBoxCast();
    }
    
    private void CheckGroundBoxCast()
    {
        // 盒形起始位置
        Vector3 boxOrigin = transform.position + Vector3.up * castOffset;
        
        // 盒形投射
        RaycastHit hit;
        IsGrounded = Physics.BoxCast(
            boxOrigin,              // 中心点
            boxSize * 0.5f,         // 半边长
            Vector3.down,           // 方向
            out hit,                // 命中信息
            Quaternion.identity,    // 旋转
            castDistance,           // 距离
            groundLayer             // 层级
        );
        
        GroundHit = hit;
    }
    
    private void OnDrawGizmos()
    {
        Vector3 boxOrigin = transform.position + Vector3.up * castOffset;
        
        // 绘制起始盒
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(boxOrigin, boxSize);
        
        // 绘制投射终点
        if (IsGrounded)
        {
            Gizmos.color = Color.green;
            Gizmos.DrawWireCube(boxOrigin + Vector3.down * GroundHit.distance, boxSize);
        }
        else
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireCube(boxOrigin + Vector3.down * castDistance, boxSize);
        }
    }
}
```

#### 2.5 完整角色控制器示例

```csharp
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class PlayerController : MonoBehaviour
{
    [Header("移动设置")]
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float jumpForce = 8f;
    
    [Header("地面检测")]
    [SerializeField] private float groundCheckDistance = 0.6f;
    [SerializeField] private float groundCheckOffset = 0.1f;
    [SerializeField] private float groundCheckRadius = 0.3f;
    [SerializeField] private LayerMask groundLayer;
    [SerializeField] private GroundCheckMethod checkMethod = GroundCheckMethod.Raycast;
    
    [Header("斜坡设置")]
    [SerializeField] private float maxSlopeAngle = 45f;
    [SerializeField] private bool slideOnSteepSlope = true;
    
    private Rigidbody rb;
    private bool isGrounded;
    private Vector3 groundNormal;
    private float groundSlopeAngle;
    
    private enum GroundCheckMethod
    {
        Raycast,
        SphereCast,
        BoxCast,
        OverlapSphere
    }
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.freezeRotation = true;
    }
    
    private void Update()
    {
        // 检测地面
        CheckGround();
        
        // 处理输入
        HandleInput();
        
        // 应用斜坡移动
        if (isGrounded && slideOnSteepSlope && groundSlopeAngle > maxSlopeAngle)
        {
            ApplySlide();
        }
    }
    
    private void FixedUpdate()
    {
        HandleMovement();
    }
    
    private void CheckGround()
    {
        Vector3 checkOrigin = transform.position + Vector3.up * groundCheckOffset;
        
        switch (checkMethod)
        {
            case GroundCheckMethod.Raycast:
                CheckGroundRaycast(checkOrigin);
                break;
            case GroundCheckMethod.SphereCast:
                CheckGroundSphereCast(checkOrigin);
                break;
            case GroundCheckMethod.BoxCast:
                CheckGroundBoxCast(checkOrigin);
                break;
            case GroundCheckMethod.OverlapSphere:
                CheckGroundOverlapSphere(checkOrigin);
                break;
        }
    }
    
    private void CheckGroundRaycast(Vector3 origin)
    {
        RaycastHit hit;
        isGrounded = Physics.Raycast(origin, Vector3.down, out hit, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundSphereCast(Vector3 origin)
    {
        RaycastHit hit;
        isGrounded = Physics.SphereCast(origin, groundCheckRadius, Vector3.down, 
            out hit, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundBoxCast(Vector3 origin)
    {
        Vector3 halfExtents = new Vector3(groundCheckRadius, 0.05f, groundCheckRadius);
        RaycastHit hit;
        isGrounded = Physics.BoxCast(origin, halfExtents, Vector3.down, 
            out hit, Quaternion.identity, groundCheckDistance, groundLayer);
        
        if (isGrounded)
        {
            groundNormal = hit.normal;
            groundSlopeAngle = Vector3.Angle(groundNormal, Vector3.up);
        }
    }
    
    private void CheckGroundOverlapSphere(Vector3 origin)
    {
        Collider[] colliders = Physics.OverlapSphere(origin, groundCheckRadius, groundLayer);
        isGrounded = colliders.Length > 0;
        
        if (isGrounded && colliders.Length > 0)
        {
            // 获取最近的地面法线
            groundNormal = Vector3.up;
            groundSlopeAngle = 0f;
        }
    }
    
    private void HandleInput()
    {
        // 跳跃
        if (isGrounded && Input.GetButtonDown("Jump"))
        {
            Jump();
        }
    }
    
    private void HandleMovement()
    {
        float horizontal = Input.GetAxisRaw("Horizontal");
        float vertical = Input.GetAxisRaw("Vertical");
        
        Vector3 moveDirection = new Vector3(horizontal, 0, vertical).normalized;
        
        // 在斜坡上调整移动方向
        if (isGrounded && groundSlopeAngle > 0 && groundSlopeAngle <= maxSlopeAngle)
        {
            moveDirection = Vector3.ProjectOnPlane(moveDirection, groundNormal).normalized;
        }
        
        Vector3 targetVelocity = moveDirection * moveSpeed;
        targetVelocity.y = rb.velocity.y;
        
        rb.velocity = targetVelocity;
    }
    
    private void Jump()
    {
        rb.velocity = new Vector3(rb.velocity.x, jumpForce, rb.velocity.z);
        isGrounded = false;
    }
    
    private void ApplySlide()
    {
        // 在陡坡上滑行
        Vector3 slideDirection = Vector3.ProjectOnPlane(Vector3.down, groundNormal).normalized;
        rb.AddForce(slideDirection * 10f, ForceMode.Acceleration);
    }
    
    private void OnDrawGizmos()
    {
        Vector3 origin = transform.position + Vector3.up * groundCheckOffset;
        
        // 绘制检测范围
        Gizmos.color = isGrounded ? Color.green : Color.red;
        
        switch (checkMethod)
        {
            case GroundCheckMethod.Raycast:
                Gizmos.DrawLine(origin, origin + Vector3.down * groundCheckDistance);
                break;
            case GroundCheckMethod.SphereCast:
                Gizmos.DrawWireSphere(origin + Vector3.down * groundCheckDistance, groundCheckRadius);
                break;
            case GroundCheckMethod.BoxCast:
                Gizmos.DrawWireCube(origin + Vector3.down * groundCheckDistance, 
                    new Vector3(groundCheckRadius * 2, 0.1f, groundCheckRadius * 2));
                break;
            case GroundCheckMethod.OverlapSphere:
                Gizmos.DrawWireSphere(origin, groundCheckRadius);
                break;
        }
        
        // 绘制地面法线
        if (isGrounded)
        {
            Gizmos.color = Color.blue;
            Gizmos.DrawRay(transform.position, groundNormal * 0.5f);
        }
    }
}
```

---

### 3. 注意事项

#### 3.1 常见问题与解决方案

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| **跳跃后无法再次跳跃** | 地面检测过于敏感，跳跃瞬间仍检测到地面 | 添加跳跃冷却时间或使用协程延迟检测 |
| **斜坡上下抖动** | 射线检测在斜坡上会误判距离 | 使用SphereCast或调整检测位置 |
| **平台边缘误判** | 单点检测在边缘不稳定 | 使用多射线或BoxCast检测 |
| **高速穿过地面** | 物体速度过快，检测间隔内穿过地面 | 使用Continuous碰撞检测或增加检测频率 |

#### 3.2 性能优化建议

```csharp
public class GroundCheckOptimized : MonoBehaviour
{
    [Header("优化设置")]
    [SerializeField] private int checkInterval = 3;     // 每3帧检测一次
    [SerializeField] private bool useNonAlloc = true;   // 使用非分配版本
    
    private Collider[] results = new Collider[5];       // 预分配数组
    private int frameCounter = 0;
    
    private void Update()
    {
        frameCounter++;
        if (frameCounter % checkInterval == 0)
        {
            CheckGroundOptimized();
        }
    }
    
    private void CheckGroundOptimized()
    {
        if (useNonAlloc)
        {
            // 使用非分配版本，避免GC
            int count = Physics.OverlapSphereNonAlloc(
                transform.position, 0.3f, results, groundLayer);
            isGrounded = count > 0;
        }
        else
        {
            // 标准版本会产生垃圾回收
            isGrounded = Physics.OverlapSphere(transform.position, 0.3f, groundLayer).Length > 0;
        }
    }
}
```

#### 3.3 最佳实践

1. **层级设置**：为地面设置专门的Layer，使用LayerMask提高检测效率
2. **调试可视化**：始终使用Gizmos或Debug.DrawRay可视化检测范围
3. **多方法结合**：复杂地形可结合多种检测方法
4. **缓存结果**：避免每帧重复计算，可缓存检测结果
5. **考虑边缘情况**：处理斜坡、移动平台、单向平台等特殊情况

#### 3.4 特殊场景处理

**移动平台检测**：
```csharp
private void OnCollisionEnter(Collision collision)
{
    if (collision.gameObject.CompareTag("MovingPlatform"))
    {
        transform.SetParent(collision.transform);
    }
}

private void OnCollisionExit(Collision collision)
{
    if (collision.gameObject.CompareTag("MovingPlatform"))
    {
        transform.SetParent(null);
    }
}
```

**跳跃缓冲（Coyote Time）**：
```csharp
[SerializeField] private float coyoteTime = 0.1f;   // 离开地面后仍可跳跃的时间
private float coyoteTimeCounter;

private void Update()
{
    if (isGrounded)
    {
        coyoteTimeCounter = coyoteTime;
    }
    else
    {
        coyoteTimeCounter -= Time.deltaTime;
    }
    
    // 跳跃条件包含coyoteTime
    if ((isGrounded || coyoteTimeCounter > 0) && Input.GetButtonDown("Jump"))
    {
        Jump();
    }
}
```
