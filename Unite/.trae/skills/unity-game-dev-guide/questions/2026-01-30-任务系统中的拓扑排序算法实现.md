# 任务系统中的拓扑排序算法实现详解

## 1. 拓扑排序的基本概念

### 1.1 什么是拓扑排序

**拓扑排序**（Topological Sorting）是一种对有向无环图（DAG）的顶点进行排序的算法，使得对于图中的每条有向边 (u, v)，顶点 u 在排序结果中都出现在顶点 v 之前。

### 1.2 拓扑排序的核心原理

- **有向无环图（DAG）**：拓扑排序只适用于有向无环图，因为如果图中存在环，就无法确定顶点的先后顺序
- **入度**：顶点的入度是指指向该顶点的边的数量
- **关键步骤**：
  1. 找出所有入度为0的顶点
  2. 从图中移除这些顶点及其所有出边
  3. 重复步骤1和2，直到所有顶点都被处理或发现环

### 1.3 拓扑排序的两种主要实现方法

1. **Kahn算法**：基于入度的迭代算法
2. **深度优先搜索（DFS）算法**：基于递归的算法

## 2. 拓扑排序在任务系统中的应用

### 2.1 任务执行顺序确定

```
任务依赖关系 → 构建有向图 → 拓扑排序 → 生成执行顺序 → 按顺序执行任务
```

### 2.2 依赖关系验证

- 检测任务依赖图中是否存在环
- 确保任务系统的逻辑一致性
- 防止玩家陷入无法完成的任务链

### 2.3 任务解锁机制

- 根据拓扑排序结果，动态解锁可执行的任务
- 为玩家提供清晰的任务进度路径
- 支持复杂的任务网络设计

### 2.4 任务优先级管理

- 在拓扑排序的基础上，考虑任务的优先级
- 实现任务的智能调度
- 优化玩家体验

## 3. 拓扑排序算法实现

### 3.1 Kahn算法实现

```csharp
using System;
using System.Collections.Generic;

public class TopologicalSort
{
    // Kahn算法实现拓扑排序
    public static List<string> KahnTopologicalSort(Dictionary<string, List<string>> graph, Dictionary<string, int> inDegree)
    {
        List<string> result = new List<string>();
        Queue<string> queue = new Queue<string>();
        
        // 初始化队列，将所有入度为0的节点加入队列
        foreach (var node in inDegree)
        {
            if (node.Value == 0)
            {
                queue.Enqueue(node.Key);
            }
        }
        
        while (queue.Count > 0)
        {
            // 取出一个入度为0的节点
            string current = queue.Dequeue();
            result.Add(current);
            
            // 遍历当前节点的所有邻接节点
            if (graph.ContainsKey(current))
            {
                foreach (string neighbor in graph[current])
                {
                    // 邻接节点的入度减1
                    inDegree[neighbor]--;
                    
                    // 如果邻接节点的入度变为0，加入队列
                    if (inDegree[neighbor] == 0)
                    {
                        queue.Enqueue(neighbor);
                    }
                }
            }
        }
        
        // 检查是否存在环
        if (result.Count != inDegree.Count)
        {
            throw new Exception("Graph contains a cycle");
        }
        
        return result;
    }
    
    // 构建任务依赖图和入度表
    public static void BuildTaskGraph(List<Task> tasks, out Dictionary<string, List<string>> graph, out Dictionary<string, int> inDegree)
    {
        graph = new Dictionary<string, List<string>>();
        inDegree = new Dictionary<string, int>();
        
        // 初始化所有任务的入度为0
        foreach (var task in tasks)
        {
            inDegree[task.id] = 0;
            graph[task.id] = new List<string>();
        }
        
        // 构建依赖关系
        foreach (var task in tasks)
        {
            if (task.dependencies != null)
            {
                foreach (var depId in task.dependencies)
                {
                    // 添加依赖边
                    graph[depId].Add(task.id);
                    // 增加入度
                    inDegree[task.id]++;
                }
            }
        }
    }
}

public class Task
{
    public string id;
    public string name;
    public List<string> dependencies;
    public TaskStatus status;
}

public enum TaskStatus
{
    Pending,
    InProgress,
    Completed,
    Failed
}
```

### 3.2 DFS算法实现

```csharp
using System;
using System.Collections.Generic;

public class TopologicalSortDFS
{
    // DFS算法实现拓扑排序
    public static List<string> DFSTopologicalSort(Dictionary<string, List<string>> graph)
    {
        Stack<string> stack = new Stack<string>();
        HashSet<string> visited = new HashSet<string>();
        HashSet<string> recursionStack = new HashSet<string>();
        
        // 对每个未访问的节点进行DFS
        foreach (var node in graph.Keys)
        {
            if (!visited.Contains(node))
            {
                if (DFS(node, graph, visited, recursionStack, stack))
                {
                    throw new Exception("Graph contains a cycle");
                }
            }
        }
        
        // 将栈转换为列表
        List<string> result = new List<string>();
        while (stack.Count > 0)
        {
            result.Add(stack.Pop());
        }
        
        return result;
    }
    
    // 深度优先搜索
    private static bool DFS(string node, Dictionary<string, List<string>> graph, HashSet<string> visited, 
                          HashSet<string> recursionStack, Stack<string> stack)
    {
        // 标记为已访问
        visited.Add(node);
        // 加入递归栈
        recursionStack.Add(node);
        
        // 遍历邻接节点
        if (graph.ContainsKey(node))
        {
            foreach (string neighbor in graph[node])
            {
                // 如果邻接节点未访问，递归访问
                if (!visited.Contains(neighbor))
                {
                    if (DFS(neighbor, graph, visited, recursionStack, stack))
                    {
                        return true;
                    }
                }
                // 如果邻接节点在递归栈中，说明存在环
                else if (recursionStack.Contains(neighbor))
                {
                    return true;
                }
            }
        }
        
        // 从递归栈中移除
        recursionStack.Remove(node);
        // 将节点加入结果栈
        stack.Push(node);
        
        return false;
    }
}
```

### 3.3 任务系统中的拓扑排序应用

```csharp
public class TaskSystem
{
    private List<Task> _tasks = new List<Task>();
    private Dictionary<string, List<string>> _dependencyGraph;
    private Dictionary<string, int> _inDegree;
    
    public void Initialize(List<Task> tasks)
    {
        _tasks = tasks;
        TopologicalSort.BuildTaskGraph(tasks, out _dependencyGraph, out _inDegree);
    }
    
    public List<string> GetTaskExecutionOrder()
    {
        try
        {
            return TopologicalSort.KahnTopologicalSort(_dependencyGraph, new Dictionary<string, int>(_inDegree));
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error in topological sort: " + ex.Message);
            return new List<string>();
        }
    }
    
    public List<string> GetAvailableTasks()
    {
        List<string> availableTasks = new List<string>();
        
        foreach (var task in _tasks)
        {
            if (task.status == TaskStatus.Pending && IsTaskAvailable(task.id))
            {
                availableTasks.Add(task.id);
            }
        }
        
        return availableTasks;
    }
    
    private bool IsTaskAvailable(string taskId)
    {
        Task task = _tasks.Find(t => t.id == taskId);
        if (task == null)
            return false;
        
        // 检查所有依赖任务是否已完成
        if (task.dependencies != null)
        {
            foreach (var depId in task.dependencies)
            {
                Task depTask = _tasks.Find(t => t.id == depId);
                if (depTask == null || depTask.status != TaskStatus.Completed)
                {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public void CompleteTask(string taskId)
    {
        Task task = _tasks.Find(t => t.id == taskId);
        if (task != null)
        {
            task.status = TaskStatus.Completed;
            // 可以在这里触发任务完成的事件，更新UI等
        }
    }
}
```

## 4. 时间复杂度和空间复杂度分析

### 4.1 Kahn算法复杂度

- **时间复杂度**：O(V + E)
  - V是顶点数（任务数）
  - E是边数（依赖关系数）
  - 每个顶点和边都只被处理一次

- **空间复杂度**：O(V + E)
  - 存储图的邻接表：O(E)
  - 存储入度表：O(V)
  - 存储结果：O(V)
  - 队列的最大空间：O(V)

### 4.2 DFS算法复杂度

- **时间复杂度**：O(V + E)
  - 每个顶点和边都只被访问一次

- **空间复杂度**：O(V + E)
  - 存储图的邻接表：O(E)
  - 递归调用栈的最大深度：O(V)
  - 存储结果：O(V)
  - 访问标记集合：O(V)

### 4.3 性能比较

| 算法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|------|------------|------------|------|------|
| Kahn | O(V+E) | O(V+E) | 易于理解和实现，可检测环 | 需要额外存储入度表 |
| DFS | O(V+E) | O(V+E) | 实现简洁，不需要入度表 | 递归深度可能导致栈溢出 |

## 5. 拓扑排序优化策略

### 5.1 增量拓扑排序

```csharp
public class IncrementalTopologicalSort
{
    private Dictionary<string, List<string>> _graph;
    private Dictionary<string, int> _inDegree;
    private List<string> _currentOrder;
    
    public void Initialize(Dictionary<string, List<string>> graph, Dictionary<string, int> inDegree)
    {
        _graph = graph;
        _inDegree = inDegree;
        _currentOrder = TopologicalSort.KahnTopologicalSort(graph, new Dictionary<string, int>(inDegree));
    }
    
    public List<string> UpdateAndSort(string updatedTaskId)
    {
        // 只重新计算受影响的部分
        // 这里可以实现增量更新逻辑
        // 例如：只重新排序依赖于updatedTaskId的任务
        
        // 简化实现：重新计算整个排序
        return TopologicalSort.KahnTopologicalSort(_graph, new Dictionary<string, int>(_inDegree));
    }
}
```

### 5.2 并行处理优化

```csharp
public class ParallelTaskExecutor
{
    public void ExecuteTasksInParallel(List<string> taskOrder, TaskSystem taskSystem)
    {
        // 分组可以并行执行的任务
        List<List<string>> parallelGroups = new List<List<string>>();
        Dictionary<string, bool> executed = new Dictionary<string, bool>();
        
        foreach (var taskId in taskOrder)
        {
            executed[taskId] = false;
        }
        
        while (executed.Any(e => !e.Value))
        {
            List<string> currentGroup = new List<string>();
            
            // 找出所有依赖已满足且未执行的任务
            foreach (var taskId in taskOrder)
            {
                if (!executed[taskId] && taskSystem.IsTaskAvailable(taskId))
                {
                    currentGroup.Add(taskId);
                }
            }
            
            // 并行执行当前组的任务
            if (currentGroup.Count > 0)
            {
                parallelGroups.Add(currentGroup);
                
                // 模拟并行执行
                foreach (var taskId in currentGroup)
                {
                    Console.WriteLine("Executing task: " + taskId);
                    taskSystem.CompleteTask(taskId);
                    executed[taskId] = true;
                }
            }
        }
        
        Console.WriteLine("Tasks executed in " + parallelGroups.Count + " parallel groups");
    }
}
```

### 5.3 缓存优化

```csharp
public class CachedTopologicalSort
{
    private Dictionary<string, List<string>> _graph;
    private Dictionary<string, int> _inDegree;
    private List<string> _cachedOrder;
    private string _cacheKey;
    
    public List<string> GetTopologicalOrder()
    {
        string currentKey = GenerateCacheKey();
        
        // 如果图没有变化，返回缓存的结果
        if (_cacheKey == currentKey && _cachedOrder != null)
        {
            return _cachedOrder;
        }
        
        // 否则重新计算
        _cachedOrder = TopologicalSort.KahnTopologicalSort(_graph, new Dictionary<string, int>(_inDegree));
        _cacheKey = currentKey;
        
        return _cachedOrder;
    }
    
    private string GenerateCacheKey()
    {
        // 生成图的哈希值作为缓存键
        string key = "";
        foreach (var node in _graph.Keys)
        {
            key += node + ":" + string.Join(",", _graph[node]) + ";";
        }
        return key.GetHashCode().ToString();
    }
}
```

### 5.4 惰性计算

```csharp
public class LazyTopologicalSort
{
    private Dictionary<string, List<string>> _graph;
    private Dictionary<string, int> _inDegree;
    private bool _isDirty;
    private List<string> _cachedResult;
    
    public void UpdateGraph(string node, List<string> neighbors)
    {
        _graph[node] = neighbors;
        _isDirty = true;
    }
    
    public List<string> GetTopologicalOrder()
    {
        if (!_isDirty && _cachedResult != null)
        {
            return _cachedResult;
        }
        
        _cachedResult = TopologicalSort.KahnTopologicalSort(_graph, new Dictionary<string, int>(_inDegree));
        _isDirty = false;
        
        return _cachedResult;
    }
}
```

## 6. 最佳实践

### 6.1 算法选择

- **小规模任务系统**：两种算法都可以，根据个人喜好选择
- **大规模任务系统**：建议使用Kahn算法，避免递归栈溢出
- **需要频繁更新的系统**：考虑使用增量拓扑排序

### 6.2 实现注意事项

- **环检测**：必须实现环检测逻辑，防止任务系统出现死循环
- **错误处理**：妥善处理拓扑排序失败的情况
- **性能优化**：对于大型任务系统，考虑使用缓存和增量更新
- **可扩展性**：设计时考虑任务系统的未来扩展

### 6.3 错误处理策略

```csharp
public class TaskSystemErrorHandler
{
    public void HandleCycleDependency(List<Task> tasks)
    {
        Console.WriteLine("Error: Task dependency graph contains cycles");
        
        // 尝试找出环
        List<string> cycle = FindCycle(tasks);
        if (cycle != null && cycle.Count > 0)
        {
            Console.WriteLine("Cycle detected: " + string.Join(" → ", cycle));
        }
        
        // 可以在这里实现自动修复逻辑，例如移除导致环的依赖
    }
    
    private List<string> FindCycle(List<Task> tasks)
    {
        // 实现环检测逻辑
        // 这里返回一个示例环
        return new List<string>();
    }
}
```

### 6.4 测试策略

- **单元测试**：测试拓扑排序算法的正确性
- **集成测试**：测试任务系统与拓扑排序的集成
- **压力测试**：测试大型任务系统的性能
- **边界测试**：测试特殊情况，如空任务列表、只有一个任务的情况等

## 7. 实际应用案例

### 7.1 角色扮演游戏任务系统

```csharp
public class RPGTaskSystem
{
    private TaskSystem _taskSystem;
    private List<Task> _allTasks;
    
    public void Initialize()
    {
        // 加载任务数据
        _allTasks = LoadTasks();
        _taskSystem = new TaskSystem();
        _taskSystem.Initialize(_allTasks);
        
        // 显示任务执行顺序
        List<string> executionOrder = _taskSystem.GetTaskExecutionOrder();
        Console.WriteLine("Task execution order:");
        foreach (var taskId in executionOrder)
        {
            Task task = _allTasks.Find(t => t.id == taskId);
            if (task != null)
            {
                Console.WriteLine($"{task.id}: {task.name}");
            }
        }
    }
    
    public void UpdateUI()
    {
        // 获取可执行的任务
        List<string> availableTasks = _taskSystem.GetAvailableTasks();
        
        // 更新UI显示
        Console.WriteLine("Available tasks:");
        foreach (var taskId in availableTasks)
        {
            Task task = _allTasks.Find(t => t.id == taskId);
            if (task != null)
            {
                Console.WriteLine($"- {task.name}");
            }
        }
    }
    
    public void OnTaskCompleted(string taskId)
    {
        _taskSystem.CompleteTask(taskId);
        UpdateUI();
        
        // 检查是否有新任务可用
        List<string> newAvailableTasks = _taskSystem.GetAvailableTasks();
        if (newAvailableTasks.Count > 0)
        {
            Console.WriteLine("New tasks available!");
        }
    }
    
    private List<Task> LoadTasks()
    {
        // 从配置文件或数据库加载任务数据
        return new List<Task>
        {
            new Task { id = "task1", name = "收集10个苹果", dependencies = null, status = TaskStatus.Pending },
            new Task { id = "task2", name = "交付苹果给村民", dependencies = new List<string> { "task1" }, status = TaskStatus.Pending },
            new Task { id = "task3", name = "击败森林中的狼", dependencies = null, status = TaskStatus.Pending },
            new Task { id = "task4", name = "获得狼皮", dependencies = new List<string> { "task3" }, status = TaskStatus.Pending },
            new Task { id = "task5", name = "制作皮革 armor", dependencies = new List<string> { "task2", "task4" }, status = TaskStatus.Pending }
        };
    }
}
```

### 7.2 开放世界游戏任务系统

```csharp
public class OpenWorldTaskSystem
{
    private Dictionary<string, TaskRegion> _regions;
    private TaskSystem _globalTaskSystem;
    
    public void Initialize()
    {
        _regions = new Dictionary<string, TaskRegion>();
        _globalTaskSystem = new TaskSystem();
        
        // 加载区域任务
        LoadRegionTasks();
        
        // 构建全局任务系统
        BuildGlobalTaskSystem();
    }
    
    private void BuildGlobalTaskSystem()
    {
        List<Task> allTasks = new List<Task>();
        
        foreach (var region in _regions.Values)
        {
            allTasks.AddRange(region.Tasks);
        }
        
        _globalTaskSystem.Initialize(allTasks);
    }
    
    public List<string> GetTasksForRegion(string regionId)
    {
        if (_regions.TryGetValue(regionId, out var region))
        {
            // 计算该区域的任务执行顺序
            return CalculateRegionTaskOrder(region);
        }
        
        return new List<string>();
    }
    
    private List<string> CalculateRegionTaskOrder(TaskRegion region)
    {
        // 构建区域任务图
        Dictionary<string, List<string>> regionGraph = new Dictionary<string, List<string>>();
        Dictionary<string, int> regionInDegree = new Dictionary<string, int>();
        
        foreach (var task in region.Tasks)
        {
            regionGraph[task.id] = new List<string>();
            regionInDegree[task.id] = 0;
        }
        
        // 添加依赖关系
        foreach (var task in region.Tasks)
        {
            if (task.dependencies != null)
            {
                foreach (var depId in task.dependencies)
                {
                    if (regionGraph.ContainsKey(depId))
                    {
                        regionGraph[depId].Add(task.id);
                        regionInDegree[task.id]++;
                    }
                }
            }
        }
        
        // 执行拓扑排序
        return TopologicalSort.KahnTopologicalSort(regionGraph, regionInDegree);
    }
}

public class TaskRegion
{
    public string id;
    public string name;
    public List<Task> Tasks;
}
```

## 8. 总结

拓扑排序算法是任务系统中不可或缺的核心技术，它：

1. **确保任务执行顺序的正确性**：通过拓扑排序，保证任务按照依赖关系的正确顺序执行
2. **检测和防止循环依赖**：确保任务系统的逻辑一致性
3. **支持复杂的任务网络设计**：为游戏设计师提供强大的工具
4. **优化玩家体验**：为玩家提供清晰的任务进度路径

在实现拓扑排序时，需要考虑：

- **算法选择**：根据任务系统的规模和特点选择合适的算法
- **性能优化**：对于大型任务系统，采用缓存、增量更新等优化策略
- **错误处理**：妥善处理环检测等异常情况
- **可扩展性**：设计时考虑任务系统的未来扩展

通过合理应用拓扑排序算法，可以构建出更加健壮、灵活和高效的任务系统，为玩家提供更加丰富和沉浸的游戏体验。