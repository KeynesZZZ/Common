---
title: "游戏开发中常用的数据结构"
date: "2026-01-30 00:00:00"
tags: [Unity, C#, 数据结构, 游戏开发]
difficulty: "中级"
topic: "核心系统"
project: "游戏引擎开发"
skill_level: "中级开发者"
---

# 游戏开发中常用的数据结构

在游戏开发中，数据结构的选择直接影响游戏的性能、内存使用和代码可维护性。不同的游戏系统和场景需要使用不同的数据结构来优化特定操作。以下是游戏开发中常用的数据结构及其应用场景：


## 一、基础线性结构

### 1. 数组（Array）
- **特点**：连续内存布局，随机访问速度快（O(1)），插入/删除元素慢（O(n)）。
- **游戏应用**：
  - 存储固定数量的游戏对象（如玩家 inventory、固定数量的敌人）。
  - 顶点数据、纹理数据等需要快速访问的资源。
  - 粒子系统中的粒子数据。
- **示例**：
  ```csharp
  // 存储敌人实例
  Enemy[] enemies = new Enemy[100];
  // 访问特定敌人
  Enemy firstEnemy = enemies[0];
  ```

### 2. 链表（Linked List）
- **特点**：非连续内存布局，插入/删除元素快（O(1)），随机访问慢（O(n)）。
- **游戏应用**：
  - 动态变化的游戏对象列表（如需要频繁添加/移除的敌人、子弹）。
  - 事件系统中的事件队列（双向链表）。
  - 物理系统中的碰撞检测候选对象列表。
- **示例**：
  ```csharp
  // 自定义简单链表节点
  public class Node<T> {
      public T Data;
      public Node<T> Next;
  }
  // 用于存储动态敌人列表
  Node<Enemy> enemyList;
  ```

### 3. 栈（Stack）
- **特点**：后进先出（LIFO），插入/删除操作在栈顶（O(1)）。
- **游戏应用**：
  - 游戏状态管理（如场景切换、UI面板层级）。
  - 撤销/重做系统（如编辑器中的操作记录）。
  - 函数调用栈（由语言本身管理，但游戏逻辑中也可使用）。
- **示例**：
  ```csharp
  // 场景状态栈
  Stack<SceneState> sceneStack = new Stack<SceneState>();
  // 压入新场景
  sceneStack.Push(new GameplayScene());
  // 弹出当前场景
  SceneState currentScene = sceneStack.Pop();
  ```

### 4. 队列（Queue）
- **特点**：先进先出（FIFO），插入在队尾，删除在队头（O(1)）。
- **游戏应用**：
  - 事件系统（如延迟执行的事件、网络消息队列）。
  - AI行为队列（如NPC的待执行任务）。
  - 资源加载队列（如异步加载资源的顺序管理）。
- **示例**：
  ```csharp
  // 事件队列
  Queue<GameEvent> eventQueue = new Queue<GameEvent>();
  // 入队事件
  eventQueue.Enqueue(new PlayerJumpEvent());
  // 出队并处理事件
  GameEvent currentEvent = eventQueue.Dequeue();
  currentEvent.Execute();
  ```


## 二、哈希表与映射结构

### 1. 哈希表（Hash Table）
- **特点**：通过哈希函数将键映射到值，平均查找/插入/删除时间复杂度为O(1)。
- **游戏应用**：
  - 游戏对象ID到实例的映射（如通过唯一ID快速查找游戏对象）。
  - 资源缓存（如纹理、音频资源的缓存）。
  - 玩家数据存储（如角色属性、装备信息）。
- **示例**：
  ```csharp
  // 游戏对象ID映射
  Dictionary<int, GameObject> objectMap = new Dictionary<int, GameObject>();
  // 添加对象
  objectMap.Add(playerId, playerObject);
  // 查找对象
  if (objectMap.TryGetValue(enemyId, out GameObject enemy)) {
      // 处理敌人
  }
  ```

### 2. 有序字典（Sorted Dictionary）
- **特点**：基于平衡树实现，键值对按键排序，查找/插入/删除时间复杂度为O(log n)。
- **游戏应用**：
  - 排行榜系统（按分数/等级排序）。
  - 资源加载优先级队列（按优先级排序）。
  - 时间线事件管理（按时间戳排序）。
- **示例**：
  ```csharp
  // 排行榜（分数->玩家ID）
  SortedDictionary<int, string> leaderboard = new SortedDictionary<int, string>();
  // 添加分数
  leaderboard.Add(1000, "Player1");
  leaderboard.Add(800, "Player2");
  // 遍历排行榜（从低到高）
  foreach (var entry in leaderboard) {
      Debug.Log($"{entry.Value}: {entry.Key}");
  }
  ```


## 三、树结构

### 1. 二叉树（Binary Tree）
- **特点**：每个节点最多有两个子节点，适用于有序数据的查找和排序。
- **游戏应用**：
  - 碰撞检测中的空间划分（如二叉空间分割树 BSP）。
  - AI决策树（如行为树的简化版）。
  - 资源管理中的层级结构（如文件目录）。

### 2. 四叉树（Quadtree）
- **特点**：二维空间划分结构，每个节点分为四个子节点，适用于2D场景。
- **游戏应用**：
  - 2D游戏中的碰撞检测优化（减少碰撞检测的对象数量）。
  - 视锥体剔除（快速判断对象是否在摄像机视野内）。
  - 粒子系统的空间管理。
- **示例**：
  ```csharp
  // 四叉树节点
  public class QuadtreeNode {
      public Rect Bounds;
      public List<GameObject> Objects;
      public QuadtreeNode[] Children; // 四个子节点
      
      // 插入对象
      public void Insert(GameObject obj) {
          // 实现插入逻辑
      }
      
      // 查询区域内的对象
      public List<GameObject> Query(Rect area) {
          // 实现查询逻辑
      }
  }
  ```

### 3. 八叉树（Octree）
- **特点**：三维空间划分结构，每个节点分为八个子节点，适用于3D场景。
- **游戏应用**：
  - 3D游戏中的碰撞检测优化。
  - 3D场景的视锥体剔除。
  - 大规模地形数据的管理。

### 4. 行为树（Behavior Tree）
- **特点**：用于AI决策的树状结构，节点分为组合节点、装饰节点和叶节点。
- **游戏应用**：
  - NPC的AI行为逻辑（如巡逻、攻击、躲避）。
  - 玩家角色的状态管理（如技能释放流程）。
- **示例**：
  ```csharp
  // 行为树节点基类
  public abstract class BTNode {
      public abstract BTStatus Execute();
  }
  
  // 叶节点（具体行为）
  public class AttackNode : BTNode {
      public override BTStatus Execute() {
          // 执行攻击行为
          return BTStatus.Success;
      }
  }
  
  // 组合节点（顺序执行）
  public class SequenceNode : BTNode {
      private List<BTNode> children;
      public override BTStatus Execute() {
          foreach (var child in children) {
              if (child.Execute() != BTStatus.Success) {
                  return BTStatus.Failure;
              }
          }
          return BTStatus.Success;
      }
  }
  ```


## 四、图结构

### 1. 无向图（Undirected Graph）
- **特点**：边无方向，适用于双向关系。
- **游戏应用**：
  - 游戏世界中的区域连接（如开放世界的区域可达性）。
  - 社交系统中的玩家关系（如好友关系）。

### 2. 有向图（Directed Graph）
- **特点**：边有方向，适用于单向关系。
- **游戏应用**：
  - AI寻路中的导航图（如节点间的移动方向）。
  - 任务系统中的任务依赖关系（如前置任务）。

### 3. 加权图（Weighted Graph）
- **特点**：边带有权重，适用于需要成本评估的场景。
- **游戏应用**：
  - 寻路算法（如A*算法，权重为移动成本）。
  - 资源流动系统（如经济系统中的资源转移成本）。
- **示例**：
  ```csharp
  // 图节点
  public class GraphNode {
      public Vector3 Position;
      public List<GraphEdge> Edges; // 相邻边
  }
  
  // 图边（带权重）
  public class GraphEdge {
      public GraphNode From;
      public GraphNode To;
      public float Weight; // 移动成本
  }
  
  // A*寻路示例
  public List<GraphNode> FindPath(GraphNode start, GraphNode goal) {
      // 实现A*算法
  }
  ```


## 五、特殊数据结构

### 1. 对象池（Object Pool）
- **特点**：预分配对象并复用，减少内存分配和垃圾回收。
- **游戏应用**：
  - 子弹、粒子等频繁创建/销毁的对象。
  - UI元素（如弹出提示、图标）。
  - 敌人实例（如波次生成的敌人）。
- **示例**：
  ```csharp
  public class ObjectPool<T> where T : MonoBehaviour {
      private Queue<T> pool = new Queue<T>();
      private T prefab;
      
      public ObjectPool(T prefab, int initialSize) {
          this.prefab = prefab;
          for (int i = 0; i < initialSize; i++) {
              T obj = Object.Instantiate(prefab);
              obj.gameObject.SetActive(false);
              pool.Enqueue(obj);
          }
      }
      
      public T Get() {
          if (pool.Count > 0) {
              T obj = pool.Dequeue();
              obj.gameObject.SetActive(true);
              return obj;
          } else {
              T obj = Object.Instantiate(prefab);
              return obj;
          }
      }
      
      public void Return(T obj) {
          obj.gameObject.SetActive(false);
          pool.Enqueue(obj);
      }
  }
  ```

### 2. 空间哈希（Spatial Hash）
- **特点**：将空间划分为网格单元格，每个单元格存储其中的对象，适用于2D/3D碰撞检测。
- **游戏应用**：
  - 粒子系统的碰撞检测。
  - 大量动态对象的接近度查询。
  - 流体模拟中的邻居搜索。

### 3.  bloom 过滤器（Bloom Filter）
- **特点**：空间高效的概率性数据结构，用于判断元素是否在集合中（可能误判，无漏判）。
- **游戏应用**：
  - 快速判断玩家是否拥有某物品（减少数据库查询）。
  - 网络消息去重。
  - 资源加载状态的快速检查。

### 4. 优先队列（Priority Queue）
- **特点**：元素按优先级排序，最高优先级元素先出队，基于堆实现。
- **游戏应用**：
  - 寻路算法（如A*算法中的开放列表）。
  - 事件系统中的优先级事件处理。
  - 资源加载的优先级管理。
- **示例**：
  ```csharp
  // 基于堆的优先队列
  public class PriorityQueue<T> where T : IComparable<T> {
      private List<T> heap = new List<T>();
      
      public void Enqueue(T item) {
          heap.Add(item);
          int i = heap.Count - 1;
          // 上浮调整
          while (i > 0 && heap[i].CompareTo(heap[(i-1)/2]) < 0) {
              Swap(i, (i-1)/2);
              i = (i-1)/2;
          }
      }
      
      public T Dequeue() {
          T min = heap[0];
          heap[0] = heap[heap.Count - 1];
          heap.RemoveAt(heap.Count - 1);
          // 下沉调整
          int i = 0;
          while (2*i + 1 < heap.Count) {
              int left = 2*i + 1;
              int right = 2*i + 2;
              int smallest = left;
              if (right < heap.Count && heap[right].CompareTo(heap[left]) < 0) {
                  smallest = right;
              }
              if (heap[i].CompareTo(heap[smallest]) > 0) {
                  Swap(i, smallest);
                  i = smallest;
              } else {
                  break;
              }
          }
          return min;
      }
      
      private void Swap(int i, int j) {
          T temp = heap[i];
          heap[i] = heap[j];
          heap[j] = temp;
      }
  }
  ```


## 六、数据结构的选择原则

在游戏开发中选择数据结构时，需要考虑以下因素：

1. **操作频率**：
   - 频繁访问：优先选择数组、哈希表。
   - 频繁插入/删除：优先选择链表、哈希表。
   - 频繁排序：优先选择有序字典、优先队列。

2. **空间复杂度**：
   - 内存受限场景（如移动设备）：优先选择空间高效的数据结构（如数组、对象池）。
   - 内存充足场景：可选择更灵活的数据结构（如链表、树）。

3. **时间复杂度**：
   - 实时性要求高的场景（如物理模拟、碰撞检测）：优先选择O(1)或O(log n)的操作。
   - 实时性要求低的场景（如资源加载、初始化）：可接受O(n)或更高复杂度的操作。

4. **场景特性**：
   - 2D场景：优先选择四叉树、空间哈希。
   - 3D场景：优先选择八叉树、BVH树。
   - 动态对象多：优先选择对象池、链表。
   - 静态对象多：优先选择数组、四叉树/八叉树。


## 七、总结

游戏开发中常用的数据结构涵盖了基础线性结构、哈希表、树结构、图结构以及特殊结构（如对象池、空间哈希）等。选择合适的数据结构可以显著优化游戏性能，提升开发效率。开发者需要根据具体场景的需求（如操作频率、空间/时间复杂度要求）来选择最适合的数据结构，甚至结合多种数据结构来解决复杂问题。

例如，在3D开放世界游戏中，可能同时使用八叉树（碰撞检测）、哈希表（对象ID映射）、对象池（粒子/子弹）、行为树（AI决策）等多种数据结构，以实现高效的游戏逻辑和渲染。