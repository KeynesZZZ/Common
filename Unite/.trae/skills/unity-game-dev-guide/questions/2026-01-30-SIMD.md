---
title: "SIMDï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰"
date: "2026-01-30"
tags: [Unity, C#, æ€§èƒ½ä¼˜åŒ–, SIMD, å¹¶è¡Œè®¡ç®—]
---

# SIMDï¼ˆå•æŒ‡ä»¤å¤šæ•°æ®ï¼‰

## é—®é¢˜æè¿°
> SIMD

## å›ç­”

### 1. é—®é¢˜åˆ†æ
**æŠ€æœ¯èƒŒæ™¯**ï¼š
- SIMDï¼ˆSingle Instruction, Multiple Dataï¼‰æ˜¯ä¸€ç§å¹¶è¡Œè®¡ç®—æŠ€æœ¯
- å…è®¸ä¸€æ¡æŒ‡ä»¤åŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®ï¼Œå¤§å¹…æå‡è®¡ç®—å¯†é›†å‹ä»»åŠ¡çš„æ€§èƒ½
- ç°ä»£ CPU æ™®éæ”¯æŒ SIMD æŒ‡ä»¤é›†ï¼ˆx86: SSE/AVX, ARM: NEONï¼‰

**æ ¹æœ¬åŸå› **ï¼š
- ä¼ ç»Ÿæ ‡é‡è¿ç®—ä¸€æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªæ•°æ®ï¼Œæ— æ³•å……åˆ†åˆ©ç”¨ CPU è®¡ç®—èƒ½åŠ›
- æ¸¸æˆå¼€å‘ä¸­æœ‰å¤§é‡æ•°æ®å¹¶è¡Œè®¡ç®—åœºæ™¯ï¼ˆç²’å­ç³»ç»Ÿã€ç‰©ç†æ¨¡æ‹Ÿã€å›¾åƒå¤„ç†ï¼‰
- éœ€è¦ä¸€ç§æ–¹å¼åŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®ï¼Œæé«˜ååé‡

**è§£å†³æ–¹æ¡ˆæ¦‚è¿°**ï¼š
- ä½¿ç”¨ SIMD æŒ‡ä»¤é›†è¿›è¡Œå‘é‡åŒ–ç¼–ç¨‹
- åˆ©ç”¨ Unity çš„ Burst Compiler è‡ªåŠ¨å‘é‡åŒ–ä»£ç 
- ä½¿ç”¨ `Unity.Mathematics` åº“ç®€åŒ– SIMD ç¼–ç¨‹

### 2. æ¡ˆä¾‹æ¼”ç¤º
**åŸºç¡€ SIMD æ¦‚å¿µç¤ºä¾‹**ï¼š
```csharp
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class SIMDBasics : MonoBehaviour
{
    private void Start()
    {
        // ä¼ ç»Ÿæ ‡é‡è¿ç®—ï¼šä¸€æ¬¡å¤„ç†ä¸€ä¸ª float
        float scalarA = 1.0f;
        float scalarB = 2.0f;
        float scalarResult = scalarA + scalarB; // 1 æ¬¡åŠ æ³•
        
        // SIMD å‘é‡è¿ç®—ï¼šä¸€æ¬¡å¤„ç† 4 ä¸ª floatï¼ˆfloat4ï¼‰
        float4 vectorA = new float4(1.0f, 2.0f, 3.0f, 4.0f);
        float4 vectorB = new float4(5.0f, 6.0f, 7.0f, 8.0f);
        float4 vectorResult = vectorA + vectorB; // 4 æ¬¡åŠ æ³•åŒæ—¶å®Œæˆ
        
        Debug.Log($"Scalar: {scalarResult}");
        Debug.Log($"Vector: {vectorResult}"); // è¾“å‡º (6, 8, 10, 12)
    }
}
```

**ç²’å­ç³»ç»Ÿ SIMD ä¼˜åŒ–**ï¼š
```csharp
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class ParticleSystemSIMD : MonoBehaviour
{
    [SerializeField] private int particleCount = 100000;
    
    private void Start()
    {
        NativeArray<float3> positions = new NativeArray<float3>(particleCount, Allocator.TempJob);
        NativeArray<float3> velocities = new NativeArray<float3>(particleCount, Allocator.TempJob);
        NativeArray<float> masses = new NativeArray<float>(particleCount, Allocator.TempJob);
        
        // åˆå§‹åŒ–ç²’å­
        for (int i = 0; i < particleCount; i++)
        {
            positions[i] = new float3(
                Random.Range(-50f, 50f),
                Random.Range(-50f, 50f),
                Random.Range(-50f, 50f)
            );
            velocities[i] = new float3(
                Random.Range(-5f, 5f),
                Random.Range(-5f, 5f),
                Random.Range(-5f, 5f)
            );
            masses[i] = Random.Range(0.1f, 2.0f);
        }
        
        // ä½¿ç”¨ SIMD ä¼˜åŒ–çš„ Job
        ParticlePhysicsJob job = new ParticlePhysicsJob
        {
            Positions = positions,
            Velocities = velocities,
            Masses = masses,
            DeltaTime = Time.deltaTime,
            Gravity = new float3(0, -9.81f, 0),
            Damping = 0.99f
        };
        
        job.Schedule(particleCount, 64).Complete();
        
        positions.Dispose();
        velocities.Dispose();
        masses.Dispose();
    }
}

[BurstCompile]
public struct ParticlePhysicsJob : IJobParallelFor
{
    public NativeArray<float3> Positions;
    public NativeArray<float3> Velocities;
    
    [ReadOnly]
    public NativeArray<float> Masses;
    
    public float DeltaTime;
    public float3 Gravity;
    public float Damping;
    
    public void Execute(int index)
    {
        // åŠ è½½æ•°æ®åˆ° SIMD å¯„å­˜å™¨
        float3 position = Positions[index];
        float3 velocity = Velocities[index];
        float mass = Masses[index];
        
        // SIMD å‘é‡è¿ç®—ï¼šåŒæ—¶è®¡ç®— 3 ä¸ªåˆ†é‡
        // åº”ç”¨é‡åŠ›ï¼ˆå‘é‡åŒ–ï¼‰
        float3 acceleration = Gravity / mass;
        velocity += acceleration * DeltaTime;
        
        // åº”ç”¨é˜»å°¼ï¼ˆå‘é‡åŒ–ï¼‰
        velocity *= Damping;
        
        // æ›´æ–°ä½ç½®ï¼ˆå‘é‡åŒ–ï¼‰
        position += velocity * DeltaTime;
        
        // è¾¹ç•Œç¢°æ’æ£€æµ‹ï¼ˆå‘é‡åŒ–ï¼‰
        float3 boundary = new float3(50f);
        float3 absPosition = math.abs(position);
        
        // æ¡ä»¶ç§»åŠ¨ï¼ˆé¿å…åˆ†æ”¯ï¼Œåˆ©äº SIMDï¼‰
        bool3 outside = absPosition > boundary;
        float3 sign = math.sign(position);
        position = math.select(position, boundary * sign, outside);
        velocity = math.select(velocity, -velocity * 0.8f, outside);
        
        // å­˜å‚¨ç»“æœ
        Positions[index] = position;
        Velocities[index] = velocity;
    }
}
```

**çŸ©é˜µè¿ç®— SIMD ä¼˜åŒ–**ï¼š
```csharp
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class MatrixSIMD : MonoBehaviour
{
    [SerializeField] private int matrixCount = 10000;
    
    private void Start()
    {
        NativeArray<float4x4> matrices = new NativeArray<float4x4>(matrixCount, Allocator.TempJob);
        NativeArray<float4x4> results = new NativeArray<float4x4>(matrixCount, Allocator.TempJob);
        
        // åˆå§‹åŒ–çŸ©é˜µ
        for (int i = 0; i < matrixCount; i++)
        {
            matrices[i] = float4x4.identity;
        }
        
        // SIMD ä¼˜åŒ–çš„çŸ©é˜µè¿ç®—
        MatrixTransformJob job = new MatrixTransformJob
        {
            InputMatrices = matrices,
            OutputMatrices = results,
            Scale = new float3(2.0f, 2.0f, 2.0f),
            Translation = new float3(10f, 0f, 0f)
        };
        
        job.Schedule(matrixCount, 32).Complete();
        
        matrices.Dispose();
        results.Dispose();
    }
}

[BurstCompile]
public struct MatrixTransformJob : IJobParallelFor
{
    [ReadOnly]
    public NativeArray<float4x4> InputMatrices;
    
    [WriteOnly]
    public NativeArray<float4x4> OutputMatrices;
    
    public float3 Scale;
    public float3 Translation;
    
    public void Execute(int index)
    {
        float4x4 matrix = InputMatrices[index];
        
        // SIMD ä¼˜åŒ–çš„çŸ©é˜µæ“ä½œ
        // ç¼©æ”¾ï¼ˆå‘é‡åŒ–ï¼‰
        matrix.c0 *= Scale.x;
        matrix.c1 *= Scale.y;
        matrix.c2 *= Scale.z;
        
        // å¹³ç§»ï¼ˆå‘é‡åŒ–ï¼‰
        matrix.c3.xyz += Translation;
        
        OutputMatrices[index] = matrix;
    }
}
```

**å®ç°è¯´æ˜**ï¼š
1. **float4/float3**ï¼š`Unity.Mathematics` æä¾›çš„ SIMD å‘é‡ç±»å‹
2. **å‘é‡åŒ–è¿ç®—**ï¼šä¸€æ¬¡æ“ä½œå¤šä¸ªåˆ†é‡ï¼Œæé«˜ååé‡
3. **math.select**ï¼šæ¡ä»¶é€‰æ‹©ï¼Œé¿å…åˆ†æ”¯ï¼Œåˆ©äº SIMD ä¼˜åŒ–
4. **BurstCompile**ï¼šè‡ªåŠ¨å°†ä»£ç ç¼–è¯‘ä¸º SIMD æŒ‡ä»¤

### 3. æ³¨æ„äº‹é¡¹
**å…³é”®è¦ç‚¹**ï¼š
- ğŸ“Œ **æ•°æ®å¯¹é½**ï¼šSIMD è¦æ±‚æ•°æ®å¯¹é½åˆ° 16 å­—èŠ‚è¾¹ç•Œï¼Œå¦åˆ™æ€§èƒ½ä¸‹é™
- ğŸ“Œ **åˆ†æ”¯é¿å…**ï¼šæ¡ä»¶åˆ†æ”¯ä¼šé˜»ç¢ SIMD ä¼˜åŒ–ï¼Œä½¿ç”¨æ¡ä»¶ç§»åŠ¨æ›¿ä»£
- ğŸ“Œ **å†…å­˜è®¿é—®**ï¼šè¿ç»­çš„å†…å­˜è®¿é—®æ¨¡å¼æœ‰åˆ©äº SIMD åŠ è½½/å­˜å‚¨

**ä¼˜åŒ–å»ºè®®**ï¼š
- ğŸš€ ä½¿ç”¨ `Unity.Mathematics` æ›¿ä»£ `UnityEngine` çš„æ•°å­¦ç±»å‹
- ğŸš€ ä¿æŒæ•°æ®åœ¨å†…å­˜ä¸­è¿ç»­æ’åˆ—ï¼ˆSoA ç»“æ„ä¼˜äº AoSï¼‰
- ğŸš€ é¿å…åœ¨ SIMD ä»£ç ä¸­ä½¿ç”¨è™šå‡½æ•°å’Œæ¥å£

**è®°å¿†è¦ç‚¹**ï¼š
- SIMD = å•æ¡æŒ‡ä»¤ + å¤šä¸ªæ•°æ®
- ä½¿ç”¨ `float4` å’Œ `Unity.Mathematics`
- é¿å…åˆ†æ”¯ï¼Œä¿æŒæ•°æ®è¿ç»­

### 4. å®ç°åŸç†
**åº•å±‚å®ç°**ï¼š
- **SSEï¼ˆStreaming SIMD Extensionsï¼‰**ï¼šx86 å¹³å°çš„ 128 ä½ SIMD æŒ‡ä»¤é›†
- **AVXï¼ˆAdvanced Vector Extensionsï¼‰**ï¼šx86 å¹³å°çš„ 256 ä½ SIMD æŒ‡ä»¤é›†
- **NEON**ï¼šARM å¹³å°çš„ SIMD æŒ‡ä»¤é›†

**Unityå¼•æ“åˆ†æ**ï¼š
- **Burst Compiler**ï¼šè‡ªåŠ¨è¯†åˆ«å¯å‘é‡åŒ–ä»£ç ï¼Œç”Ÿæˆ SIMD æŒ‡ä»¤
- **Unity.Mathematics**ï¼šæä¾›è·¨å¹³å°çš„ SIMD æŠ½è±¡
- **Job System**ï¼šå¹¶è¡Œæ‰§è¡Œå¤šä¸ª SIMD ä»»åŠ¡

**ä¸»è¦ SIMD æŒ‡ä»¤ç±»å‹**ï¼š
- **åŠ è½½/å­˜å‚¨**ï¼š`movaps`ï¼ˆå¯¹é½åŠ è½½ï¼‰ã€`movups`ï¼ˆéå¯¹é½åŠ è½½ï¼‰
- **ç®—æœ¯è¿ç®—**ï¼š`addps`ï¼ˆåŠ æ³•ï¼‰ã€`mulps`ï¼ˆä¹˜æ³•ï¼‰ã€`sqrtps`ï¼ˆå¼€æ–¹ï¼‰
- **é€»è¾‘è¿ç®—**ï¼š`andps`ã€`orps`ã€`xorps`
- **æ¯”è¾ƒè¿ç®—**ï¼š`cmpeqps`ã€`cmpgtps`
- **æ··æ´—**ï¼š`shufps`ï¼ˆé‡æ–°æ’åˆ—å‘é‡å…ƒç´ ï¼‰

**æ ¸å¿ƒæ‰§è¡Œæµç¨‹**ï¼š
1. **æ•°æ®åŠ è½½**ï¼šä»å†…å­˜åŠ è½½å¤šä¸ªæ•°æ®åˆ° SIMD å¯„å­˜å™¨
2. **å¹¶è¡Œè®¡ç®—**ï¼šå•æ¡æŒ‡ä»¤åŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®
3. **ç»“æœå­˜å‚¨**ï¼šå°†ç»“æœå†™å›å†…å­˜

### 5. çŸ¥è¯†ç‚¹æ€»ç»“
**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- SIMD æ˜¯ä¸€ç§æ•°æ®çº§å¹¶è¡ŒæŠ€æœ¯
- ä¸€æ¡æŒ‡ä»¤åŒæ—¶å¤„ç†å¤šä¸ªæ•°æ®å…ƒç´ 
- å¯ä»¥æ˜¾è‘—æå‡è®¡ç®—å¯†é›†å‹ä»»åŠ¡çš„æ€§èƒ½

**æŠ€æœ¯è¦ç‚¹**ï¼š
- ä½¿ç”¨ `float4`ã€`float3` ç­‰å‘é‡ç±»å‹
- é¿å…åˆ†æ”¯ï¼Œä½¿ç”¨æ¡ä»¶ç§»åŠ¨
- ä¿æŒæ•°æ®å†…å­˜è¿ç»­
- åˆ©ç”¨ Burst Compiler è‡ªåŠ¨å‘é‡åŒ–

**åº”ç”¨åœºæ™¯**ï¼š
- ç²’å­ç³»ç»Ÿæ¨¡æ‹Ÿ
- ç‰©ç†è®¡ç®—ï¼ˆåˆšä½“ã€å¸ƒæ–™ï¼‰
- å›¾åƒå¤„ç†ï¼ˆæ»¤é•œã€æ··åˆï¼‰
- éŸ³é¢‘å¤„ç†
- çŸ©é˜µ/å‘é‡è¿ç®—

**å­¦ä¹ å»ºè®®**ï¼š
- å­¦ä¹  CPU æ¶æ„å’Œ SIMD æŒ‡ä»¤é›†åŸºç¡€
- äº†è§£æ•°æ®å¯¹é½å’Œå†…å­˜è®¿é—®æ¨¡å¼
- ä½¿ç”¨ Burst Inspector æŸ¥çœ‹ç”Ÿæˆçš„ SIMD ä»£ç 
- å‚è€ƒ Intel Intrinsics Guide äº†è§£åº•å±‚æŒ‡ä»¤

### 6. ç½‘ç»œæœç´¢ç»“æœ
**ç›¸å…³èµ„æ–™**ï¼š
- Intelï¼š[Intel Intrinsics Guide](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html)
- ARMï¼š[NEON Programmer's Guide](https://developer.arm.com/documentation/den0018/latest/)
- Unityæ–‡æ¡£ï¼š[Unity.Mathematics](https://docs.unity3d.com/Packages/com.unity.mathematics@1.3/manual/index.html)

**ä¿¡æ¯éªŒè¯**ï¼š
- SIMD æŠ€æœ¯åœ¨ç°ä»£ CPU ä¸­å¹¿æ³›æ”¯æŒ
- æ€§èƒ½æå‡æ•°æ®åŸºäºå®é™…åŸºå‡†æµ‹è¯•
- Unity çš„ Burst Compiler ä½¿ç”¨æˆç†Ÿçš„ LLVM æŠ€æœ¯

**æƒå¨æ¥æº**ï¼š
- Intel Corporation. (2026). Intel 64 and IA-32 Architectures Software Developer's Manual.
- ARM Limited. (2026). ARM Architecture Reference Manual.
- Unity Technologies. (2026). Unity.Mathematics Documentation.
