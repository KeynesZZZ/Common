---
title: "C#反射详解"
date: "2026-01-30 00:00:00"
tags: [Unity, C#, 反射, 运行时, 元数据]
---

# C#反射详解

## 问题描述
深入讲解C#反射的工作原理、核心API和在Unity中的应用场景，包括性能优化策略和最佳实践。

## 回答

### 1. 问题分析

反射（Reflection）是C#中的一个强大特性，它允许程序在运行时检查和操作类型、对象、方法和属性等。通过反射，程序可以动态地创建对象、调用方法、访问属性，而不需要在编译时知道这些类型的具体信息。在Unity开发中，反射被广泛应用于各种场景，如编辑器扩展、序列化、依赖注入等。

反射的核心工作原理基于.NET的元数据系统。元数据是存储在程序集中的关于类型、成员和引用的信息。当编译器编译C#代码时，它会生成IL（中间语言）代码和相应的元数据，反射通过读取这些元数据来获取类型信息。

反射的主要应用场景包括：
- 动态创建对象
- 动态调用方法
- 动态访问属性和字段
- 动态加载程序集
- 实现插件系统
- 序列化和反序列化
- 依赖注入

### 2. 案例演示

#### 2.1 核心API使用示例

```csharp
// 获取Type对象的多种方式
Type stringType = typeof(string);
string s = "hello";
Type instanceType = s.GetType();
Type dynamicType = Type.GetType("System.String");

// 获取类型信息
string name = stringType.Name;
string fullName = stringType.FullName;
string @namespace = stringType.Namespace;
Type baseType = stringType.BaseType;
Type[] interfaces = stringType.GetInterfaces();

// 获取类型成员
ConstructorInfo[] constructors = stringType.GetConstructors();
MethodInfo[] methods = stringType.GetMethods();
PropertyInfo[] properties = stringType.GetProperties();
FieldInfo[] fields = stringType.GetFields();
EventInfo[] events = stringType.GetEvents();

// 创建实例
object stringInstance = Activator.CreateInstance(typeof(string), new char[] { 'h', 'e', 'l', 'l', 'o' });

// 调用方法
MethodInfo concatMethod = typeof(string).GetMethod("Concat", new Type[] { typeof(string), typeof(string) });
object result = concatMethod.Invoke(null, new object[] { "Hello", " World" });

// 访问属性
PropertyInfo lengthProperty = typeof(string).GetProperty("Length");
int length = (int)lengthProperty.GetValue("Hello");

// 访问字段
FieldInfo charsField = typeof(string).GetField("m_firstChar", BindingFlags.NonPublic | BindingFlags.Instance);
char firstChar = (char)charsField.GetValue("Hello");
```

#### 2.2 动态加载程序集

```csharp
// 加载程序集
Assembly assembly = Assembly.LoadFrom("Plugins/MyPlugin.dll");

// 获取类型
Type pluginType = assembly.GetType("MyPlugin.Plugin");

// 创建实例
object plugin = Activator.CreateInstance(pluginType);

// 调用方法
MethodInfo initializeMethod = pluginType.GetMethod("Initialize");
initializeMethod.Invoke(plugin, null);

MethodInfo executeMethod = pluginType.GetMethod("Execute", new Type[] { typeof(string) });
executeMethod.Invoke(plugin, new object[] { "test parameter" });
```

#### 2.3 实现插件系统

```csharp
// 插件接口
public interface IPlugin
{
    void Initialize();
    void Execute();
    void Dispose();
}

// 加载插件
public List<IPlugin> LoadPlugins(string directory)
{
    List<IPlugin> plugins = new List<IPlugin>();
    
    // 遍历目录中的DLL文件
    foreach (string file in Directory.GetFiles(directory, "*.dll"))
    {
        try
        {
            // 加载程序集
            Assembly assembly = Assembly.LoadFrom(file);
            
            // 遍历程序集中的类型
            foreach (Type type in assembly.GetTypes())
            {
                // 检查类型是否实现了IPlugin接口
                if (typeof(IPlugin).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract)
                {
                    // 创建插件实例
                    IPlugin plugin = (IPlugin)Activator.CreateInstance(type);
                    plugin.Initialize();
                    plugins.Add(plugin);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading plugin {file}: {ex.Message}");
        }
    }
    
    return plugins;
}
```

#### 2.4 Unity中的依赖注入

```csharp
// 简单的依赖注入容器
public class DIContainer : MonoBehaviour
{
    private Dictionary<Type, object> _instances = new Dictionary<Type, object>();
    private Dictionary<Type, Type> _registrations = new Dictionary<Type, Type>();
    
    public static DIContainer Instance { get; private set; }
    
    private void Awake()
    {
        Instance = this;
    }
    
    public void Register<TInterface, TImplementation>() where TImplementation : TInterface
    {
        _registrations[typeof(TInterface)] = typeof(TImplementation);
    }
    
    public void RegisterSingleton<T>(T instance) where T : class
    {
        _instances[typeof(T)] = instance;
    }
    
    public T Resolve<T>()
    {
        Type type = typeof(T);
        
        // 检查是否已有实例
        if (_instances.TryGetValue(type, out object instance))
        {
            return (T)instance;
        }
        
        // 检查是否有注册
        if (_registrations.TryGetValue(type, out Type implementationType))
        {
            // 创建实例
            T newInstance = (T)Activator.CreateInstance(implementationType);
            _instances[type] = newInstance;
            return newInstance;
        }
        
        throw new Exception($"Type {type.Name} not registered");
    }
    
    // 自动注入MonoBehaviour
    public void Inject(MonoBehaviour monoBehaviour)
    {
        Type type = monoBehaviour.GetType();
        
        // 注入字段
        foreach (FieldInfo field in type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance))
        {
            // 检查字段是否有Inject属性
            if (field.GetCustomAttributes(typeof(InjectAttribute), true).Length > 0)
            {
                object instance = Resolve(field.FieldType);
                field.SetValue(monoBehaviour, instance);
            }
        }
    }
}

// 注入属性
[AttributeUsage(AttributeTargets.Field)]
public class InjectAttribute : Attribute { }

// 使用示例
public class PlayerController : MonoBehaviour
{
    [Inject]
    private IGameManager _gameManager;
    
    [Inject]
    private IPlayerStats _playerStats;
    
    private void Awake()
    {
        DIContainer.Instance.Inject(this);
    }
    
    private void Start()
    {
        _gameManager.StartGame();
        _playerStats.Reset();
    }
}
```

#### 2.5 性能优化示例

```csharp
// 缓存反射信息
public class ReflectionCache
{
    private static Dictionary<Type, Dictionary<string, MethodInfo>> _methodCache = new Dictionary<Type, Dictionary<string, MethodInfo>>();
    private static Dictionary<Type, Dictionary<string, PropertyInfo>> _propertyCache = new Dictionary<Type, Dictionary<string, PropertyInfo>>();
    
    public static MethodInfo GetMethod(Type type, string methodName)
    {
        if (!_methodCache.ContainsKey(type))
        {
            _methodCache[type] = new Dictionary<string, MethodInfo>();
        }
        
        if (!_methodCache[type].TryGetValue(methodName, out MethodInfo method))
        {
            method = type.GetMethod(methodName);
            _methodCache[type][methodName] = method;
        }
        
        return method;
    }
    
    public static PropertyInfo GetProperty(Type type, string propertyName)
    {
        if (!_propertyCache.ContainsKey(type))
        {
            _propertyCache[type] = new Dictionary<string, PropertyInfo>();
        }
        
        if (!_propertyCache[type].TryGetValue(propertyName, out PropertyInfo property))
        {
            property = type.GetProperty(propertyName);
            _propertyCache[type][propertyName] = property;
        }
        
        return property;
    }
}

// 使用委托提高性能
public static class DelegateFactory
{
    public static Func<object, object[], object> CreateMethodDelegate(MethodInfo method)
    {
        // 创建参数表达式
        ParameterExpression instanceParam = Expression.Parameter(typeof(object), "instance");
        ParameterExpression argsParam = Expression.Parameter(typeof(object[]), "args");
        
        // 创建参数数组访问表达式
        List<Expression> argExpressions = new List<Expression>();
        ParameterInfo[] parameters = method.GetParameters();
        for (int i = 0; i < parameters.Length; i++)
        {
            ParameterInfo param = parameters[i];
            Expression argAccess = Expression.ArrayIndex(argsParam, Expression.Constant(i));
            Expression argCast = Expression.Convert(argAccess, param.ParameterType);
            argExpressions.Add(argCast);
        }
        
        // 创建方法调用表达式
        Expression instanceCast = method.IsStatic ? null : Expression.Convert(instanceParam, method.DeclaringType);
        Expression methodCall = Expression.Call(instanceCast, method, argExpressions);
        
        // 创建返回值转换表达式
        Expression resultCast = Expression.Convert(methodCall, typeof(object));
        
        // 创建lambda表达式并编译为委托
        LambdaExpression lambda = Expression.Lambda<Func<object, object[], object>>(resultCast, instanceParam, argsParam);
        return (Func<object, object[], object>)lambda.Compile();
    }
}
```

### 3. 注意事项

#### 3.1 性能考虑

- **反射的性能开销**：反射操作比直接调用慢，主要因为元数据查找、动态调用、装箱拆箱和安全检查等开销
- **性能优化策略**：
  - 缓存Type和MemberInfo对象
  - 使用Delegate.CreateDelegate或表达式树提高调用速度
  - 减少反射使用，尽量使用编译时类型
  - 只在必要时使用反射

#### 3.2 安全考虑

- **访问权限**：反射可以访问私有成员，可能破坏封装性
- **异常处理**：反射操作可能抛出各种异常，需要妥善处理
- **版本兼容性**：反射依赖于类型的名称和结构，可能在版本更新时失效

#### 3.3 最佳实践

- **缓存反射信息**：避免重复获取Type和MemberInfo对象
- **使用委托提高性能**：对于频繁调用的方法，使用委托或表达式树
- **异常处理**：妥善处理反射操作可能抛出的异常
- **代码注释**：为反射代码添加详细的注释，提高可读性
- **考虑替代方案**：在某些情况下，考虑使用接口、泛型等替代方案

#### 3.4 常见陷阱

- **方法重载**：当类型有多个重载方法时，需要指定准确的参数类型
- **访问修饰符**：访问私有成员时需要添加BindingFlags.NonPublic
- **静态与实例**：区分静态成员和实例成员的获取方式
- **性能滥用**：在性能关键路径上过度使用反射

#### 3.5 Unity特定注意事项

- **编辑器与运行时**：某些反射操作在编辑器中可行，但在运行时可能受限
- **IL2CPP**：使用IL2CPP编译时，反射可能受到更多限制
- **热更新**：在热更新场景中，反射是实现动态加载的重要手段
- **序列化**：Unity的序列化系统大量使用反射

### 4. 性能比较

| 操作方式 | 性能 | 灵活性 |
|---------|------|--------|
| 直接调用 | 最快 | 最低 |
| 委托调用 | 快 | 中等 |
| 表达式树 | 较快 | 高 |
| 反射调用 | 慢 | 最高 |
| dynamic调用 | 较慢 | 高 |

### 5. 总结

反射是C#中的一个强大特性，它为程序提供了运行时类型检查和操作的能力。在Unity开发中，反射被广泛应用于编辑器扩展、序列化、依赖注入等场景。通过合理使用反射，开发者可以编写更加灵活、可扩展的代码，同时避免反射带来的性能问题和维护困难。

掌握反射的使用方法，可以大大提高开发效率和代码质量，特别是在需要动态性和扩展性的场景中。然而，开发者也应该注意反射的性能开销和潜在的安全问题，在使用时权衡利弊，选择最合适的实现方式。