---
title: "ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹"
date: "2026-01-30"
tags: [Unity, C#, å¤šçº¿ç¨‹, å¼‚æ­¥ç¼–ç¨‹, æ¶æ„è®¾è®¡]
---

# ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

## é—®é¢˜æè¿°
> ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

## å›ç­”

### 1. é—®é¢˜åˆ†æ
**æŠ€æœ¯èƒŒæ™¯**ï¼š
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼ˆProducer-Consumer Patternï¼‰æ˜¯å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­çš„ç»å…¸è®¾è®¡æ¨¡å¼
- ç”¨äºè§£å†³ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´çš„é€Ÿåº¦ä¸åŒ¹é…é—®é¢˜ï¼Œå®ç°å¼‚æ­¥è§£è€¦
- åœ¨æ¸¸æˆå¼€å‘ä¸­å¸¸ç”¨äºèµ„æºåŠ è½½ã€ä»»åŠ¡å¤„ç†ã€ç½‘ç»œé€šä¿¡ç­‰åœºæ™¯

**æ ¹æœ¬åŸå› **ï¼š
- æ¸¸æˆä¸»çº¿ç¨‹éœ€è¦ä¿æŒæµç•…ï¼Œä¸èƒ½æ‰§è¡Œè€—æ—¶æ“ä½œ
- æŸäº›ä»»åŠ¡ï¼ˆå¦‚èµ„æºåŠ è½½ã€AIè®¡ç®—ï¼‰éœ€è¦å¼‚æ­¥æ‰§è¡Œ
- éœ€è¦ä¸€ç§æœºåˆ¶æ¥åè°ƒå¼‚æ­¥ä»»åŠ¡çš„ç”Ÿæˆå’Œå¤„ç†

**è§£å†³æ–¹æ¡ˆæ¦‚è¿°**ï¼š
- ä½¿ç”¨é˜Ÿåˆ—ä½œä¸ºç¼“å†²åŒºï¼Œç”Ÿäº§è€…å°†ä»»åŠ¡æ”¾å…¥é˜Ÿåˆ—ï¼Œæ¶ˆè´¹è€…ä»é˜Ÿåˆ—å–å‡ºå¤„ç†
- å®ç°çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—æ“ä½œï¼Œé¿å…ç«æ€æ¡ä»¶
- æ”¯æŒUnityä¸»çº¿ç¨‹å’Œåå°çº¿ç¨‹çš„åä½œ

### 2. æ¡ˆä¾‹æ¼”ç¤º
**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;

// ä»»åŠ¡æ•°æ®
public class GameTask
{
    public string TaskId { get; set; }
    public TaskType Type { get; set; }
    public object Data { get; set; }
    public Action<object> Callback { get; set; }
    
    public GameTask(string taskId, TaskType type, object data, Action<object> callback = null)
    {
        TaskId = taskId;
        Type = type;
        Data = data;
        Callback = callback;
    }
}

public enum TaskType
{
    LoadAsset,
    GenerateMesh,
    Pathfinding,
    SaveData,
    NetworkRequest
}

// ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç®¡ç†å™¨
public class ProducerConsumerManager : MonoBehaviour
{
    [SerializeField] private int workerCount = 2; // æ¶ˆè´¹è€…çº¿ç¨‹æ•°
    
    // çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ—
    private ConcurrentQueue<GameTask> taskQueue = new ConcurrentQueue<GameTask>();
    
    // å·²å®Œæˆä»»åŠ¡é˜Ÿåˆ—ï¼ˆç”¨äºä¸»çº¿ç¨‹å›è°ƒï¼‰
    private ConcurrentQueue<GameTask> completedTasks = new ConcurrentQueue<GameTask>();
    
    private CancellationTokenSource cancellationTokenSource;
    private Task[] workerTasks;
    
    private void Start()
    {
        InitializeWorkers();
    }
    
    private void OnDestroy()
    {
        StopWorkers();
    }
    
    private void Update()
    {
        // åœ¨ä¸»çº¿ç¨‹å¤„ç†å·²å®Œæˆçš„ä»»åŠ¡å›è°ƒ
        ProcessCompletedTasks();
    }
    
    // åˆå§‹åŒ–æ¶ˆè´¹è€…çº¿ç¨‹
    private void InitializeWorkers()
    {
        cancellationTokenSource = new CancellationTokenSource();
        workerTasks = new Task[workerCount];
        
        for (int i = 0; i < workerCount; i++)
        {
            int workerId = i;
            workerTasks[i] = Task.Run(() => WorkerLoop(workerId, cancellationTokenSource.Token));
        }
        
        Debug.Log($"Initialized {workerCount} worker threads");
    }
    
    // æ¶ˆè´¹è€…å·¥ä½œå¾ªç¯
    private void WorkerLoop(int workerId, CancellationToken token)
    {
        Debug.Log($"Worker {workerId} started");
        
        while (!token.IsCancellationRequested)
        {
            if (taskQueue.TryDequeue(out GameTask task))
            {
                try
                {
                    // å¤„ç†ä»»åŠ¡
                    object result = ProcessTask(task);
                    
                    // å°†ç»“æœå­˜å…¥å·²å®Œæˆé˜Ÿåˆ—
                    task.Data = result;
                    completedTasks.Enqueue(task);
                    
                    Debug.Log($"Worker {workerId} completed task: {task.TaskId}");
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Worker {workerId} failed to process task {task.TaskId}: {ex.Message}");
                }
            }
            else
            {
                // é˜Ÿåˆ—ä¸ºç©ºæ—¶çŸ­æš‚ä¼‘çœ ï¼Œé¿å…CPUç©ºè½¬
                Thread.Sleep(10);
            }
        }
        
        Debug.Log($"Worker {workerId} stopped");
    }
    
    // å¤„ç†å…·ä½“ä»»åŠ¡
    private object ProcessTask(GameTask task)
    {
        switch (task.Type)
        {
            case TaskType.LoadAsset:
                return LoadAsset(task.Data);
                
            case TaskType.GenerateMesh:
                return GenerateMesh(task.Data);
                
            case TaskType.Pathfinding:
                return CalculatePath(task.Data);
                
            case TaskType.SaveData:
                return SaveGameData(task.Data);
                
            case TaskType.NetworkRequest:
                return MakeNetworkRequest(task.Data);
                
            default:
                throw new NotSupportedException($"Task type {task.Type} not supported");
        }
    }
    
    // ç”Ÿäº§è€…æ–¹æ³•ï¼šæ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
    public void EnqueueTask(GameTask task)
    {
        taskQueue.Enqueue(task);
        Debug.Log($"Task enqueued: {task.TaskId}");
    }
    
    // ä¾¿æ·æ–¹æ³•ï¼šåˆ›å»ºå¹¶æ·»åŠ ä»»åŠ¡
    public void CreateTask(TaskType type, object data, Action<object> callback = null)
    {
        string taskId = Guid.NewGuid().ToString();
        GameTask task = new GameTask(taskId, type, data, callback);
        EnqueueTask(task);
    }
    
    // åœ¨ä¸»çº¿ç¨‹å¤„ç†å·²å®Œæˆçš„ä»»åŠ¡
    private void ProcessCompletedTasks()
    {
        while (completedTasks.TryDequeue(out GameTask task))
        {
            // åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œå›è°ƒ
            task.Callback?.Invoke(task.Data);
        }
    }
    
    // åœæ­¢æ‰€æœ‰æ¶ˆè´¹è€…çº¿ç¨‹
    private void StopWorkers()
    {
        cancellationTokenSource?.Cancel();
        
        // ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
        if (workerTasks != null)
        {
            Task.WaitAll(workerTasks, 5000);
        }
        
        cancellationTokenSource?.Dispose();
    }
    
    // æ¨¡æ‹Ÿä»»åŠ¡å¤„ç†æ–¹æ³•
    private object LoadAsset(object data)
    {
        string assetPath = (string)data;
        // æ¨¡æ‹ŸåŠ è½½è€—æ—¶
        Thread.Sleep(100);
        return $"Loaded: {assetPath}";
    }
    
    private object GenerateMesh(object data)
    {
        MeshData meshData = (MeshData)data;
        // æ¨¡æ‹Ÿç½‘æ ¼ç”Ÿæˆè€—æ—¶
        Thread.Sleep(200);
        return new Mesh(); // è¿”å›ç”Ÿæˆçš„ç½‘æ ¼
    }
    
    private object CalculatePath(object data)
    {
        PathRequest request = (PathRequest)data;
        // æ¨¡æ‹Ÿå¯»è·¯è®¡ç®—
        Thread.Sleep(50);
        return new Vector3[] { request.Start, request.End }; // è¿”å›è·¯å¾„ç‚¹
    }
    
    private object SaveGameData(object data)
    {
        SaveData saveData = (SaveData)data;
        // æ¨¡æ‹Ÿä¿å­˜è€—æ—¶
        Thread.Sleep(100);
        return true; // è¿”å›ä¿å­˜æˆåŠŸ
    }
    
    private object MakeNetworkRequest(object data)
    {
        string url = (string)data;
        // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
        Thread.Sleep(300);
        return $"Response from {url}";
    }
    
    // è·å–é˜Ÿåˆ—çŠ¶æ€
    public (int pending, int completed) GetQueueStatus()
    {
        return (taskQueue.Count, completedTasks.Count);
    }
}

// è¾…åŠ©æ•°æ®ç»“æ„
public class MeshData
{
    public Vector3[] Vertices;
    public int[] Triangles;
}

public class PathRequest
{
    public Vector3 Start;
    public Vector3 End;
}

public class SaveData
{
    public string PlayerName;
    public int Level;
    public float PlayTime;
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```csharp
using UnityEngine;

public class ProducerConsumerExample : MonoBehaviour
{
    private ProducerConsumerManager manager;
    
    private void Start()
    {
        manager = FindObjectOfType<ProducerConsumerManager>();
        
        // ç¤ºä¾‹1ï¼šå¼‚æ­¥åŠ è½½èµ„æº
        manager.CreateTask(TaskType.LoadAsset, "Assets/Textures/Player.png", result =>
        {
            Debug.Log($"Asset loaded: {result}");
            // åœ¨ä¸»çº¿ç¨‹æ›´æ–°UI
        });
        
        // ç¤ºä¾‹2ï¼šå¼‚æ­¥ç”Ÿæˆç½‘æ ¼
        MeshData meshData = new MeshData
        {
            Vertices = new Vector3[] { Vector3.zero, Vector3.up, Vector3.right },
            Triangles = new int[] { 0, 1, 2 }
        };
        
        manager.CreateTask(TaskType.GenerateMesh, meshData, result =>
        {
            Mesh mesh = (Mesh)result;
            GetComponent<MeshFilter>().mesh = mesh;
            Debug.Log("Mesh generated and applied");
        });
        
        // ç¤ºä¾‹3ï¼šå¼‚æ­¥å¯»è·¯
        PathRequest pathRequest = new PathRequest
        {
            Start = transform.position,
            End = new Vector3(10, 0, 10)
        };
        
        manager.CreateTask(TaskType.Pathfinding, pathRequest, result =>
        {
            Vector3[] path = (Vector3[])result;
            Debug.Log($"Path found with {path.Length} waypoints");
        });
        
        // ç¤ºä¾‹4ï¼šå¼‚æ­¥ä¿å­˜
        SaveData saveData = new SaveData
        {
            PlayerName = "Player1",
            Level = 5,
            PlayTime = 3600
        };
        
        manager.CreateTask(TaskType.SaveData, saveData, result =>
        {
            bool success = (bool)result;
            Debug.Log($"Save completed: {success}");
        });
    }
    
    private void Update()
    {
        // æŒ‰ç©ºæ ¼é”®æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
        if (Input.GetKeyDown(KeyCode.Space))
        {
            var status = manager.GetQueueStatus();
            Debug.Log($"Pending tasks: {status.pending}, Completed tasks: {status.completed}");
        }
    }
}
```

**Unity Job System ç‰ˆæœ¬ï¼ˆæ›´é«˜æ•ˆçš„å®ç°ï¼‰**ï¼š
```csharp
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

// Job System ç‰ˆæœ¬çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…
public class JobSystemProducerConsumer : MonoBehaviour
{
    // ç¤ºä¾‹ï¼šä½¿ç”¨IJobParallelForå¤„ç†å¤§é‡æ•°æ®
    struct ProcessDataJob : IJobParallelFor
    {
        [ReadOnly]
        public NativeArray<float> InputData;
        
        [WriteOnly]
        public NativeArray<float> OutputData;
        
        public void Execute(int index)
        {
            // æ¨¡æ‹Ÿå¤æ‚è®¡ç®—
            float value = InputData[index];
            OutputData[index] = value * value + Mathf.Sin(value);
        }
    }
    
    private void Start()
    {
        // åˆ›å»ºå¤§é‡æ•°æ®
        int dataSize = 10000;
        NativeArray<float> inputData = new NativeArray<float>(dataSize, Allocator.TempJob);
        NativeArray<float> outputData = new NativeArray<float>(dataSize, Allocator.TempJob);
        
        // å¡«å……è¾“å…¥æ•°æ®
        for (int i = 0; i < dataSize; i++)
        {
            inputData[i] = i * 0.1f;
        }
        
        // åˆ›å»ºå¹¶è°ƒåº¦Job
        ProcessDataJob job = new ProcessDataJob
        {
            InputData = inputData,
            OutputData = outputData
        };
        
        JobHandle jobHandle = job.Schedule(dataSize, 64);
        
        // å¯ä»¥ç»§ç»­åšå…¶ä»–äº‹æƒ…...
        
        // ç­‰å¾…Jobå®Œæˆ
        jobHandle.Complete();
        
        // ä½¿ç”¨ç»“æœ
        Debug.Log($"First result: {outputData[0]}, Last result: {outputData[dataSize - 1]}");
        
        // é‡Šæ”¾NativeArray
        inputData.Dispose();
        outputData.Dispose();
    }
}
```

**å®ç°è¯´æ˜**ï¼š
1. **ConcurrentQueue**ï¼šä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„å¹¶å‘é˜Ÿåˆ—ï¼Œé¿å…é”ç«äº‰
2. **CancellationToken**ï¼šæ”¯æŒä¼˜é›…åœ°åœæ­¢æ¶ˆè´¹è€…çº¿ç¨‹
3. **ä¸»çº¿ç¨‹å›è°ƒ**ï¼šåœ¨`Update`ä¸­å¤„ç†å·²å®Œæˆçš„ä»»åŠ¡ï¼Œç¡®ä¿Unity APIåœ¨ä¸»çº¿ç¨‹è°ƒç”¨
4. **Job Systemç‰ˆæœ¬**ï¼šåˆ©ç”¨Unityçš„Job Systemå®ç°æ›´é«˜æ•ˆçš„å¹¶è¡Œå¤„ç†

### 3. æ³¨æ„äº‹é¡¹
**å…³é”®è¦ç‚¹**ï¼š
- ğŸ“Œ **çº¿ç¨‹å®‰å…¨**ï¼šä½¿ç”¨`ConcurrentQueue`ç­‰çº¿ç¨‹å®‰å…¨é›†åˆï¼Œé¿å…æ‰‹åŠ¨åŠ é”
- ğŸ“Œ **ä¸»çº¿ç¨‹é™åˆ¶**ï¼šUnity APIï¼ˆå¦‚Transformæ“ä½œï¼‰å¿…é¡»åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ
- ğŸ“Œ **èµ„æºé‡Šæ”¾**ï¼šæ­£ç¡®é‡Šæ”¾NativeArrayç­‰èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼

**ä¼˜åŒ–å»ºè®®**ï¼š
- ğŸš€ æ ¹æ®CPUæ ¸å¿ƒæ•°è°ƒæ•´æ¶ˆè´¹è€…çº¿ç¨‹æ•°
- ğŸš€ ä½¿ç”¨Unity Job Systemæ›¿ä»£æ‰‹åŠ¨çº¿ç¨‹ï¼Œè·å¾—æ›´å¥½çš„æ€§èƒ½
- ğŸš€ å®ç°ä»»åŠ¡ä¼˜å…ˆçº§ç³»ç»Ÿï¼Œä¼˜å…ˆå¤„ç†é‡è¦ä»»åŠ¡

**è®°å¿†è¦ç‚¹**ï¼š
- ç”Ÿäº§è€…-æ¶ˆè´¹è€… = é˜Ÿåˆ— + å¤šçº¿ç¨‹ + å¼‚æ­¥å›è°ƒ
- ä¸»çº¿ç¨‹è´Ÿè´£Unity APIè°ƒç”¨ï¼Œåå°çº¿ç¨‹è´Ÿè´£è€—æ—¶è®¡ç®—
- ä½¿ç”¨çº¿ç¨‹å®‰å…¨é›†åˆé¿å…ç«æ€æ¡ä»¶

### 4. å®ç°åŸç†
**åº•å±‚å®ç°**ï¼š
- ä½¿ç”¨FIFOé˜Ÿåˆ—ä½œä¸ºç¼“å†²åŒºï¼Œè§£è€¦ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
- ç”Ÿäº§è€…çº¿ç¨‹å°†ä»»åŠ¡æ”¾å…¥é˜Ÿåˆ—ï¼Œæ¶ˆè´¹è€…çº¿ç¨‹ä»é˜Ÿåˆ—å–å‡ºå¤„ç†
- ä½¿ç”¨`ConcurrentQueue`å®ç°æ— é”å¹¶å‘ï¼Œæé«˜æ€§èƒ½

**Unityå¼•æ“åˆ†æ**ï¼š
- Unityä¸»çº¿ç¨‹è´Ÿè´£æ¸²æŸ“å’ŒMonoBehaviourç”Ÿå‘½å‘¨æœŸ
- åå°çº¿ç¨‹é€šè¿‡`ConcurrentQueue`ä¸ä¸»çº¿ç¨‹é€šä¿¡
- Job Systemæä¾›æ›´é«˜æ•ˆçš„å¹¶è¡Œè®¡ç®—ï¼Œè‡ªåŠ¨ç®¡ç†çº¿ç¨‹æ± 

**ä¸»è¦æ¥å£å’ŒAPI**ï¼š
- `ConcurrentQueue<T>`ï¼šçº¿ç¨‹å®‰å…¨çš„å¹¶å‘é˜Ÿåˆ—
- `CancellationTokenSource`ï¼šå–æ¶ˆä»¤ç‰Œæºï¼Œç”¨äºåœæ­¢çº¿ç¨‹
- `Task.Run()`ï¼šåœ¨åå°çº¿ç¨‹æ‰§è¡Œä»»åŠ¡
- `IJobParallelFor`ï¼šJob Systemå¹¶è¡Œä»»åŠ¡æ¥å£
- `NativeArray<T>`ï¼šJob Systemä½¿ç”¨çš„åŸç”Ÿæ•°ç»„

**æ ¸å¿ƒé€»è¾‘æµç¨‹**ï¼š
1. **åˆå§‹åŒ–**ï¼šåˆ›å»ºä»»åŠ¡é˜Ÿåˆ—å’Œæ¶ˆè´¹è€…çº¿ç¨‹
2. **ç”Ÿäº§ä»»åŠ¡**ï¼šä¸»çº¿ç¨‹å°†ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—
3. **æ¶ˆè´¹ä»»åŠ¡**ï¼šæ¶ˆè´¹è€…çº¿ç¨‹ä»é˜Ÿåˆ—å–å‡ºå¹¶å¤„ç†ä»»åŠ¡
4. **å›è°ƒå¤„ç†**ï¼šä¸»çº¿ç¨‹åœ¨`Update`ä¸­å¤„ç†å·²å®Œæˆä»»åŠ¡çš„å›è°ƒ
5. **èµ„æºæ¸…ç†**ï¼šåœæ­¢çº¿ç¨‹å¹¶é‡Šæ”¾èµ„æº

### 5. çŸ¥è¯†ç‚¹æ€»ç»“
**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹è§£è€¦äº†ä»»åŠ¡ç”Ÿæˆå’Œä»»åŠ¡å¤„ç†
- ä½¿ç”¨é˜Ÿåˆ—ä½œä¸ºç¼“å†²åŒºï¼Œå¹³è¡¡ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„é€Ÿåº¦å·®å¼‚
- å¤šçº¿ç¨‹å¤„ç†æå‡æ€§èƒ½ï¼Œä½†éœ€è¦æ³¨æ„çº¿ç¨‹å®‰å…¨å’Œä¸»çº¿ç¨‹é™åˆ¶

**æŠ€æœ¯è¦ç‚¹**ï¼š
- ä½¿ç”¨`ConcurrentQueue`å®ç°çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ—
- æ¶ˆè´¹è€…çº¿ç¨‹åœ¨åå°å¤„ç†ä»»åŠ¡ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
- é€šè¿‡å›è°ƒæœºåˆ¶åœ¨ä¸»çº¿ç¨‹æ›´æ–°Unityå¯¹è±¡
- Job Systemæä¾›æ›´é«˜æ•ˆçš„å¹¶è¡Œè®¡ç®—æ–¹æ¡ˆ

**åº”ç”¨åœºæ™¯**ï¼š
- èµ„æºå¼‚æ­¥åŠ è½½ï¼ˆçº¹ç†ã€æ¨¡å‹ã€éŸ³é¢‘ï¼‰
- AIå¯»è·¯è®¡ç®—
- å¤§è§„æ¨¡æ•°æ®å¤„ç†ï¼ˆåœ°å½¢ç”Ÿæˆã€ç½‘æ ¼ç”Ÿæˆï¼‰
- ç½‘ç»œè¯·æ±‚å¤„ç†
- æ¸¸æˆæ•°æ®ä¿å­˜/åŠ è½½

**å­¦ä¹ å»ºè®®**ï¼š
- æ·±å…¥å­¦ä¹ C#å¤šçº¿ç¨‹ç¼–ç¨‹å’Œçº¿ç¨‹åŒæ­¥æœºåˆ¶
- äº†è§£Unity Job Systemå’ŒBurst Compiler
- å­¦ä¹ å…¶ä»–å¹¶å‘æ¨¡å¼ï¼ˆå¦‚Actoræ¨¡å‹ã€æ•°æ®æµç¼–ç¨‹ï¼‰
- å‚è€ƒUnityå®˜æ–¹çš„å¤šçº¿ç¨‹ç¼–ç¨‹æŒ‡å—

### 6. ç½‘ç»œæœç´¢ç»“æœ
**ç›¸å…³èµ„æ–™**ï¼š
- Microsoft Docsï¼š[Producer-Consumer Pattern](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/producer-consumer-pattern)
- Unityå®˜æ–¹æ–‡æ¡£ï¼š[Job System](https://docs.unity3d.com/Manual/JobSystem.html)
- GDCæ¼”è®²ï¼š[Multi-threading in Unity](https://www.gdcvault.com/play/1025556/-Job-System-and-Burst)

**ä¿¡æ¯éªŒè¯**ï¼š
- ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ç»å…¸è®¾è®¡æ¨¡å¼
- Unity Job Systemæ˜¯å®˜æ–¹æ¨èçš„é«˜æ€§èƒ½å¹¶è¡Œè®¡ç®—æ–¹æ¡ˆ
- ä»£ç å®ç°ç¬¦åˆC#å’ŒUnityçš„æœ€ä½³å®è·µ

**æƒå¨æ¥æº**ï¼š
- Microsoft. (2026). .NET Documentation.
- Unity Technologies. (2026). Unity Manual: Job System.
- GDC Vault. (2026). Unity Performance Optimization.
