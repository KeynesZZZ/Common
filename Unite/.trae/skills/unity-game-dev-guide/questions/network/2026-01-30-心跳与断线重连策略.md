---
title: "å¿ƒè·³ä¸æ–­çº¿é‡è¿ç­–ç•¥"
date: "2026-01-30 11:30:00"
tags: [Unity, ç½‘ç»œç¼–ç¨‹, å¿ƒè·³æœºåˆ¶, æ–­çº¿é‡è¿, æ¸¸æˆå¼€å‘]
difficulty: "ä¸­çº§"
topic: "ç½‘ç»œç¼–ç¨‹"
project: "å¤šäººåœ¨çº¿æ¸¸æˆ"
skill_level: "ä¸­çº§"
---

# å¿ƒè·³ä¸æ–­çº¿é‡è¿ç­–ç•¥

## é—®é¢˜æè¿°
> è¯·è¯¦ç»†è§£é‡Šå¿ƒè·³æœºåˆ¶çš„åŸç†å’Œå®ç°æ–¹æ³•ï¼Œä»¥åŠåœ¨æ¸¸æˆå¼€å‘ä¸­å¦‚ä½•è®¾è®¡æœ‰æ•ˆçš„æ–­çº¿é‡è¿ç­–ç•¥ã€‚

## å›ç­”

### 1. é—®é¢˜åˆ†æ
**æŠ€æœ¯èƒŒæ™¯**ï¼š
- åœ¨ç½‘ç»œé€šä¿¡ä¸­ï¼Œè¿æ¥å¯èƒ½å› ä¸ºç½‘ç»œæ³¢åŠ¨ã€è·¯ç”±å™¨é‡å¯ã€é˜²ç«å¢™ç­‰åŸå› è€Œæ–­å¼€
- è¿™äº›æ–­å¼€å¯èƒ½æ˜¯çªç„¶çš„ï¼Œæ²¡æœ‰æ˜æ˜¾çš„é”™è¯¯æç¤º
- æ¸¸æˆéœ€è¦åŠæ—¶æ£€æµ‹åˆ°è¿™äº›æ–­å¼€ï¼Œå¹¶å°è¯•é‡æ–°è¿æ¥ï¼Œä»¥æä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒ
- å¿ƒè·³æœºåˆ¶æ˜¯æ£€æµ‹è¿æ¥çŠ¶æ€çš„å¸¸ç”¨æ–¹æ³•ï¼Œé€šè¿‡å®šæœŸå‘é€å°æ•°æ®åŒ…æ¥éªŒè¯è¿æ¥æ˜¯å¦ä»ç„¶æ´»è·ƒ

**æ ¹æœ¬åŸå› **ï¼š
- TCPçš„ä¿æ´»æœºåˆ¶ï¼ˆTCP Keep-Aliveï¼‰é»˜è®¤å¯ç”¨ï¼Œä½†é—´éš”è¾ƒé•¿ï¼ˆé€šå¸¸ä¸º2å°æ—¶ï¼‰ï¼Œä¸é€‚åˆæ¸¸æˆå®æ—¶æ€§è¦æ±‚
- ç½‘ç»œè®¾å¤‡å¯èƒ½ä¼šä¸»åŠ¨æ–­å¼€ç©ºé—²è¿æ¥
- ç§»åŠ¨è®¾å¤‡çš„ç½‘ç»œåˆ‡æ¢ï¼ˆå¦‚ä»WiFiåˆ°ç§»åŠ¨æ•°æ®ï¼‰å¯èƒ½å¯¼è‡´è¿æ¥ä¸­æ–­
- æ¸¸æˆéœ€è¦æ¯”åº•å±‚åè®®æ›´å¿«åœ°æ£€æµ‹è¿æ¥çŠ¶æ€

**è§£å†³æ–¹æ¡ˆæ¦‚è¿°**ï¼š
- å®ç°è‡ªå®šä¹‰å¿ƒè·³æœºåˆ¶ï¼Œå®šæœŸå‘é€å¿ƒè·³åŒ…
- è®¾è®¡åˆç†çš„å¿ƒè·³é—´éš”å’Œè¶…æ—¶æ—¶é—´
- å®ç°æ–­çº¿æ£€æµ‹å’Œé‡è¿é€»è¾‘
- å¤„ç†é‡è¿è¿‡ç¨‹ä¸­çš„çŠ¶æ€åŒæ­¥
- æä¾›å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µ

**æŠ€æœ¯éš¾åº¦**ï¼šä¸­çº§
**é€‚ç”¨åœºæ™¯**ï¼šæ‰€æœ‰éœ€è¦ä¿æŒé•¿è¿æ¥çš„æ¸¸æˆï¼Œç‰¹åˆ«æ˜¯å®æ—¶å¤šäººæ¸¸æˆ
**å…³è”é¡¹ç›®**ï¼šå¤šäººåœ¨çº¿è§’è‰²æ‰®æ¼”æ¸¸æˆï¼ˆMMORPGï¼‰ã€ç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆï¼ˆFPSï¼‰ã€å¤šäººåœ¨çº¿æˆ˜æ–— arenaï¼ˆMOBAï¼‰

### 2. æ¡ˆä¾‹æ¼”ç¤º

#### å¿ƒè·³æœºåˆ¶å®ç°

**1. å¿ƒè·³åŒ…è®¾è®¡**
**å®ç°æ€è·¯**ï¼š
- è®¾è®¡ç®€å•çš„å¿ƒè·³åŒ…ç»“æ„ï¼ŒåŒ…å«æ—¶é—´æˆ³å’Œåºåˆ—å·
- å¿ƒè·³åŒ…åº”è¯¥å°½é‡å°ï¼Œå‡å°‘ç½‘ç»œå¼€é”€
- æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯éƒ½å¯ä»¥å‘é€å¿ƒè·³åŒ…

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
public class HeartbeatPacket
{
    public uint Timestamp { get; set; }
    public ushort SequenceNumber { get; set; }
    
    public HeartbeatPacket(uint timestamp, ushort sequenceNumber)
    {
        Timestamp = timestamp;
        SequenceNumber = sequenceNumber;
    }
    
    public byte[] Serialize()
    {
        byte[] packet = new byte[6];
        Buffer.BlockCopy(BitConverter.GetBytes(Timestamp), 0, packet, 0, 4);
        Buffer.BlockCopy(BitConverter.GetBytes(SequenceNumber), 0, packet, 4, 2);
        return packet;
    }
    
    public static HeartbeatPacket Deserialize(byte[] data)
    {
        uint timestamp = BitConverter.ToUInt32(data, 0);
        ushort sequenceNumber = BitConverter.ToUInt16(data, 4);
        return new HeartbeatPacket(timestamp, sequenceNumber);
    }
}
```

**2. å®¢æˆ·ç«¯å¿ƒè·³å®ç°**
**å®ç°æ€è·¯**ï¼š
- å®šæœŸå‘é€å¿ƒè·³åŒ…åˆ°æœåŠ¡å™¨
- ç›‘å¬æœåŠ¡å™¨çš„å¿ƒè·³å“åº”
- æ£€æµ‹å¿ƒè·³è¶…æ—¶ï¼Œè§¦å‘æ–­çº¿é‡è¿

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using UnityEngine;

public class ClientHeartbeat : MonoBehaviour
{
    private TcpClient client;
    private NetworkStream stream;
    private Thread receiveThread;
    private Thread heartbeatThread;
    private bool isConnected = false;
    private bool isRunning = false;
    
    [SerializeField] private string serverIP = "127.0.0.1";
    [SerializeField] private int serverPort = 8888;
    [SerializeField] private float heartbeatInterval = 5.0f; // å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰
    [SerializeField] private float heartbeatTimeout = 15.0f; // å¿ƒè·³è¶…æ—¶ï¼ˆç§’ï¼‰
    
    private ushort heartbeatSequence = 0;
    private float lastHeartbeatSent = 0;
    private float lastHeartbeatReceived = 0;
    private int reconnectAttempts = 0;
    private const int MaxReconnectAttempts = 5;
    private const float ReconnectDelay = 3.0f;
    
    public event Action OnConnected;
    public event Action OnDisconnected;
    public event Action OnReconnected;
    
    private void Start()
    {
        Connect();
    }
    
    public void Connect()
    {
        try
        {
            client = new TcpClient();
            client.Connect(serverIP, serverPort);
            stream = client.GetStream();
            isConnected = true;
            isRunning = true;
            reconnectAttempts = 0;
            
            lastHeartbeatSent = Time.time;
            lastHeartbeatReceived = Time.time;
            
            receiveThread = new Thread(ReceiveMessages);
            receiveThread.Start();
            
            heartbeatThread = new Thread(SendHeartbeats);
            heartbeatThread.Start();
            
            Debug.Log("Connected to server successfully!");
            OnConnected?.Invoke();
        }
        catch (Exception e)
        {
            Debug.LogError("Connection error: " + e.Message);
            AttemptReconnect();
        }
    }
    
    private void SendHeartbeats()
    {
        while (isRunning)
        {
            try
            {
                if (isConnected && Time.time - lastHeartbeatSent > heartbeatInterval)
                {
                    uint timestamp = (uint)DateTimeOffset.UtcNow.ToUnixTimeSeconds();
                    HeartbeatPacket heartbeat = new HeartbeatPacket(timestamp, heartbeatSequence++);
                    byte[] data = heartbeat.Serialize();
                    
                    // å‘é€å¿ƒè·³åŒ…
                    byte[] packet = new byte[2 + data.Length];
                    Buffer.BlockCopy(BitConverter.GetBytes((ushort)1), 0, packet, 0, 2); // 1è¡¨ç¤ºå¿ƒè·³åŒ…
                    Buffer.BlockCopy(data, 0, packet, 2, data.Length);
                    
                    stream.Write(packet, 0, packet.Length);
                    stream.Flush();
                    
                    lastHeartbeatSent = Time.time;
                    Debug.Log("Heartbeat sent: " + timestamp);
                }
                
                // æ£€æµ‹å¿ƒè·³è¶…æ—¶
                if (isConnected && Time.time - lastHeartbeatReceived > heartbeatTimeout)
                {
                    Debug.LogWarning("Heartbeat timeout detected!");
                    Disconnect();
                    AttemptReconnect();
                }
                
                Thread.Sleep(100); // é¿å…å¿™ç­‰
            }
            catch (Exception e)
            {
                Debug.LogError("Heartbeat error: " + e.Message);
                if (isConnected)
                {
                    Disconnect();
                    AttemptReconnect();
                }
            }
        }
    }
    
    private void ReceiveMessages()
    {
        byte[] buffer = new byte[1024];
        
        while (isRunning)
        {
            try
            {
                if (stream.DataAvailable)
                {
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    if (bytesRead > 0)
                    {
                        // è§£ææ¶ˆæ¯ç±»å‹
                        ushort messageType = BitConverter.ToUInt16(buffer, 0);
                        
                        if (messageType == 1)
                        {
                            // å¤„ç†å¿ƒè·³å“åº”
                            HeartbeatPacket heartbeat = HeartbeatPacket.Deserialize(new ArraySegment<byte>(buffer, 2, bytesRead - 2).ToArray());
                            lastHeartbeatReceived = Time.time;
                            Debug.Log("Heartbeat received: " + heartbeat.Timestamp);
                        }
                        else
                        {
                            // å¤„ç†å…¶ä»–æ¶ˆæ¯
                            HandleOtherMessages(buffer, bytesRead);
                        }
                    }
                }
                else
                {
                    Thread.Sleep(10); // é¿å…å¿™ç­‰
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Receive error: " + e.Message);
                if (isConnected)
                {
                    Disconnect();
                    AttemptReconnect();
                }
            }
        }
    }
    
    private void HandleOtherMessages(byte[] buffer, int bytesRead)
    {
        // å¤„ç†å…¶ä»–ç±»å‹çš„æ¶ˆæ¯
        string message = Encoding.UTF8.GetString(buffer, 2, bytesRead - 2);
        Debug.Log("Received message: " + message);
    }
    
    private void AttemptReconnect()
    {
        if (reconnectAttempts < MaxReconnectAttempts)
        {
            reconnectAttempts++;
            Debug.Log($"Attempting to reconnect... (Attempt {reconnectAttempts}/{MaxReconnectAttempts})");
            
            // å»¶è¿Ÿé‡è¿ï¼Œé¿å…ç«‹å³é‡è¯•å¯¼è‡´çš„å¤±è´¥
            Thread.Sleep((int)(ReconnectDelay * 1000));
            Connect();
        }
        else
        {
            Debug.LogError("Max reconnect attempts reached. Connection failed.");
            OnDisconnected?.Invoke();
        }
    }
    
    private void Disconnect()
    {
        isConnected = false;
        
        try
        {
            if (stream != null)
            {
                stream.Close();
            }
            if (client != null)
            {
                client.Close();
            }
        }
        catch (Exception e)
        {
            Debug.LogError("Disconnect error: " + e.Message);
        }
        
        Debug.Log("Disconnected from server");
    }
    
    public void SendMessage(string message)
    {
        if (isConnected)
        {
            try
            {
                byte[] data = Encoding.UTF8.GetBytes(message);
                byte[] packet = new byte[2 + data.Length];
                Buffer.BlockCopy(BitConverter.GetBytes((ushort)2), 0, packet, 0, 2); // 2è¡¨ç¤ºæ™®é€šæ¶ˆæ¯
                Buffer.BlockCopy(data, 0, packet, 2, data.Length);
                
                stream.Write(packet, 0, packet.Length);
                stream.Flush();
            }
            catch (Exception e)
            {
                Debug.LogError("Send error: " + e.Message);
                Disconnect();
                AttemptReconnect();
            }
        }
    }
    
    private void OnApplicationQuit()
    {
        isRunning = false;
        Disconnect();
        
        if (receiveThread != null && receiveThread.IsAlive)
        {
            receiveThread.Abort();
        }
        if (heartbeatThread != null && heartbeatThread.IsAlive)
        {
            heartbeatThread.Abort();
        }
    }
}
```

**3. æœåŠ¡å™¨ç«¯å¿ƒè·³å®ç°**
**å®ç°æ€è·¯**ï¼š
- ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥ç»´æŠ¤å¿ƒè·³çŠ¶æ€
- æ¥æ”¶å®¢æˆ·ç«¯çš„å¿ƒè·³åŒ…å¹¶å›å¤
- æ£€æµ‹å®¢æˆ·ç«¯çš„å¿ƒè·³è¶…æ—¶ï¼Œä¸»åŠ¨æ–­å¼€è¿æ¥

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

public class ServerHeartbeat
{
    private TcpListener listener;
    private bool isRunning = false;
    private Thread listenThread;
    private Dictionary<TcpClient, ClientConnection> clients = new Dictionary<TcpClient, ClientConnection>();
    
    [SerializeField] private int port = 8888;
    [SerializeField] private float heartbeatInterval = 5.0f; // å¿ƒè·³é—´éš”ï¼ˆç§’ï¼‰
    [SerializeField] private float heartbeatTimeout = 15.0f; // å¿ƒè·³è¶…æ—¶ï¼ˆç§’ï¼‰
    
    private void Start()
    {
        StartServer();
    }
    
    public void StartServer()
    {
        try
        {
            listener = new TcpListener(IPAddress.Any, port);
            listener.Start();
            isRunning = true;
            
            listenThread = new Thread(ListenForClients);
            listenThread.Start();
            
            Thread monitorThread = new Thread(MonitorConnections);
            monitorThread.Start();
            
            Console.WriteLine("Server started on port " + port);
        }
        catch (Exception e)
        {
            Console.WriteLine("Server start error: " + e.Message);
        }
    }
    
    private void ListenForClients()
    {
        while (isRunning)
        {
            try
            {
                TcpClient client = listener.AcceptTcpClient();
                ClientConnection connection = new ClientConnection(client, this);
                clients[client] = connection;
                
                Console.WriteLine("Client connected: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error accepting client: " + e.Message);
            }
        }
    }
    
    private void MonitorConnections()
    {
        while (isRunning)
        {
            List<TcpClient> toRemove = new List<TcpClient>();
            
            foreach (var kvp in clients)
            {
                TcpClient client = kvp.Key;
                ClientConnection connection = kvp.Value;
                
                if (!connection.IsAlive && Time.time - connection.LastHeartbeatReceived > heartbeatTimeout)
                {
                    toRemove.Add(client);
                    Console.WriteLine("Client timed out: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
                }
            }
            
            foreach (TcpClient client in toRemove)
            {
                if (clients.TryGetValue(client, out ClientConnection connection))
                {
                    connection.Close();
                    clients.Remove(client);
                }
            }
            
            Thread.Sleep(1000);
        }
    }
    
    public void RemoveClient(TcpClient client)
    {
        if (clients.ContainsKey(client))
        {
            clients.Remove(client);
        }
    }
    
    public void StopServer()
    {
        isRunning = false;
        
        foreach (var kvp in clients)
        {
            kvp.Value.Close();
        }
        clients.Clear();
        
        if (listenThread != null && listenThread.IsAlive)
        {
            listenThread.Abort();
        }
        
        if (listener != null)
        {
            listener.Stop();
        }
    }
    
    private class ClientConnection
    {
        private TcpClient client;
        private NetworkStream stream;
        private Thread receiveThread;
        private ServerHeartbeat server;
        private bool isAlive = true;
        
        public bool IsAlive => isAlive;
        public float LastHeartbeatReceived { get; private set; } = Time.time;
        private ushort heartbeatSequence = 0;
        
        public ClientConnection(TcpClient client, ServerHeartbeat server)
        {
            this.client = client;
            this.server = server;
            this.stream = client.GetStream();
            
            receiveThread = new Thread(ReceiveMessages);
            receiveThread.Start();
        }
        
        private void ReceiveMessages()
        {
            byte[] buffer = new byte[1024];
            
            while (isAlive)
            {
                try
                {
                    if (stream.DataAvailable)
                    {
                        int bytesRead = stream.Read(buffer, 0, buffer.Length);
                        if (bytesRead > 0)
                        {
                            // è§£ææ¶ˆæ¯ç±»å‹
                            ushort messageType = BitConverter.ToUInt16(buffer, 0);
                            
                            if (messageType == 1)
                            {
                                // å¤„ç†å¿ƒè·³åŒ…
                                HeartbeatPacket heartbeat = HeartbeatPacket.Deserialize(new ArraySegment<byte>(buffer, 2, bytesRead - 2).ToArray());
                                LastHeartbeatReceived = Time.time;
                                
                                // å›å¤å¿ƒè·³åŒ…
                                SendHeartbeatResponse();
                                
                                Console.WriteLine("Received heartbeat from client: " + heartbeat.SequenceNumber);
                            }
                            else if (messageType == 2)
                            {
                                // å¤„ç†æ™®é€šæ¶ˆæ¯
                                string message = Encoding.UTF8.GetString(buffer, 2, bytesRead - 2);
                                Console.WriteLine("Received message from client: " + message);
                                
                                // å›æ˜¾æ¶ˆæ¯
                                SendMessage("Server: " + message);
                            }
                        }
                    }
                    else
                    {
                        Thread.Sleep(10);
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Client error: " + e.Message);
                    Close();
                }
            }
        }
        
        private void SendHeartbeatResponse()
        {
            try
            {
                uint timestamp = (uint)DateTimeOffset.UtcNow.ToUnixTimeSeconds();
                HeartbeatPacket heartbeat = new HeartbeatPacket(timestamp, heartbeatSequence++);
                byte[] data = heartbeat.Serialize();
                
                // å‘é€å¿ƒè·³å“åº”
                byte[] packet = new byte[2 + data.Length];
                Buffer.BlockCopy(BitConverter.GetBytes((ushort)1), 0, packet, 0, 2); // 1è¡¨ç¤ºå¿ƒè·³åŒ…
                Buffer.BlockCopy(data, 0, packet, 2, data.Length);
                
                stream.Write(packet, 0, packet.Length);
                stream.Flush();
            }
            catch (Exception e)
            {
                Console.WriteLine("Error sending heartbeat response: " + e.Message);
            }
        }
        
        private void SendMessage(string message)
        {
            try
            {
                byte[] data = Encoding.UTF8.GetBytes(message);
                byte[] packet = new byte[2 + data.Length];
                Buffer.BlockCopy(BitConverter.GetBytes((ushort)2), 0, packet, 0, 2); // 2è¡¨ç¤ºæ™®é€šæ¶ˆæ¯
                Buffer.BlockCopy(data, 0, packet, 2, data.Length);
                
                stream.Write(packet, 0, packet.Length);
                stream.Flush();
            }
            catch (Exception e)
            {
                Console.WriteLine("Error sending message: " + e.Message);
            }
        }
        
        public void Close()
        {
            isAlive = false;
            
            try
            {
                if (stream != null)
                {
                    stream.Close();
                }
                if (client != null)
                {
                    client.Close();
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error closing connection: " + e.Message);
            }
            
            server.RemoveClient(client);
            Console.WriteLine("Client disconnected: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
        }
    }
}
```

**4. æ–­çº¿é‡è¿ç­–ç•¥**
**å®ç°æ€è·¯**ï¼š
- æŒ‡æ•°é€€é¿é‡è¿ï¼šæ¯æ¬¡é‡è¿å¤±è´¥åï¼Œå¢åŠ é‡è¿å»¶è¿Ÿæ—¶é—´
- é‡è¿æ¬¡æ•°é™åˆ¶ï¼šé¿å…æ— é™é‡è¿æ¶ˆè€—èµ„æº
- ç½‘ç»œçŠ¶æ€æ£€æµ‹ï¼šåœ¨é‡è¿å‰æ£€æµ‹ç½‘ç»œçŠ¶æ€
- é‡è¿æˆåŠŸåçš„çŠ¶æ€åŒæ­¥ï¼šç¡®ä¿é‡è¿åæ¸¸æˆçŠ¶æ€çš„ä¸€è‡´æ€§

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
public class ReconnectManager : MonoBehaviour
{
    [SerializeField] private ClientHeartbeat networkClient;
    [SerializeField] private int maxReconnectAttempts = 5;
    [SerializeField] private float baseReconnectDelay = 1.0f;
    [SerializeField] private float maxReconnectDelay = 30.0f;
    
    private int reconnectAttempts = 0;
    private float reconnectDelay = 0;
    private bool isReconnecting = false;
    private Queue<string> pendingMessages = new Queue<string>();
    
    public event Action OnReconnectStarted;
    public event Action OnReconnectSucceeded;
    public event Action OnReconnectFailed;
    
    private void Start()
    {
        networkClient.OnDisconnected += HandleDisconnected;
        networkClient.OnReconnected += HandleReconnected;
    }
    
    private void HandleDisconnected()
    {
        if (!isReconnecting)
        {
            StartReconnect();
        }
    }
    
    private void HandleReconnected()
    {
        isReconnecting = false;
        reconnectAttempts = 0;
        reconnectDelay = 0;
        
        // å‘é€é‡è¿å‰ç§¯ç´¯çš„æ¶ˆæ¯
        while (pendingMessages.Count > 0)
        {
            string message = pendingMessages.Dequeue();
            networkClient.SendMessage(message);
        }
        
        OnReconnectSucceeded?.Invoke();
        Debug.Log("Reconnected successfully!");
    }
    
    public void StartReconnect()
    {
        if (reconnectAttempts >= maxReconnectAttempts)
        {
            OnReconnectFailed?.Invoke();
            Debug.LogError("Max reconnect attempts reached. Giving up.");
            return;
        }
        
        isReconnecting = true;
        reconnectAttempts++;
        
        // æŒ‡æ•°é€€é¿ç­–ç•¥
        reconnectDelay = Mathf.Min(baseReconnectDelay * Mathf.Pow(2, reconnectAttempts - 1), maxReconnectDelay);
        
        Debug.Log($"Starting reconnect attempt {reconnectAttempts}/{maxReconnectAttempts} in {reconnectDelay:F2} seconds...");
        OnReconnectStarted?.Invoke();
        
        StartCoroutine(ReconnectAfterDelay());
    }
    
    private IEnumerator ReconnectAfterDelay()
    {
        yield return new WaitForSeconds(reconnectDelay);
        
        if (isReconnecting)
        {
            Debug.Log("Attempting to reconnect...");
            networkClient.Connect();
        }
    }
    
    public void SendMessageWithReconnect(string message)
    {
        if (networkClient.IsConnected)
        {
            networkClient.SendMessage(message);
        }
        else
        {
            // å­˜å‚¨æ¶ˆæ¯ï¼Œé‡è¿åå‘é€
            pendingMessages.Enqueue(message);
            
            if (!isReconnecting)
            {
                StartReconnect();
            }
        }
    }
    
    public void CancelReconnect()
    {
        isReconnecting = false;
        reconnectAttempts = 0;
        reconnectDelay = 0;
        pendingMessages.Clear();
        
        Debug.Log("Reconnect cancelled.");
    }
    
    private void OnApplicationQuit()
    {
        CancelReconnect();
    }
}
```

**å®ç°è¯´æ˜**ï¼š
- **å¿ƒè·³æœºåˆ¶**ï¼šå®šæœŸå‘é€å¿ƒè·³åŒ…ï¼Œæ£€æµ‹è¿æ¥çŠ¶æ€
- **æ–­çº¿æ£€æµ‹**ï¼šé€šè¿‡å¿ƒè·³è¶…æ—¶æ£€æµ‹æ–­çº¿æƒ…å†µ
- **é‡è¿ç­–ç•¥**ï¼šä½¿ç”¨æŒ‡æ•°é€€é¿ç®—æ³•ï¼Œé¿å…é¢‘ç¹é‡è¿
- **çŠ¶æ€åŒæ­¥**ï¼šé‡è¿æˆåŠŸåå‘é€ç§¯ç´¯çš„æ¶ˆæ¯ï¼Œç¡®ä¿çŠ¶æ€ä¸€è‡´æ€§
- **å®Œæ•´å®ç°**ï¼šæä¾›äº†å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯çš„å®Œæ•´ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•é›†æˆå¿ƒè·³æœºåˆ¶å’Œé‡è¿ç­–ç•¥

### 3. æ³¨æ„äº‹é¡¹
**å…³é”®è¦ç‚¹**ï¼š
- ğŸ“Œ å¿ƒè·³é—´éš”è®¾ç½®ï¼šå¿ƒè·³é—´éš”åº”æ ¹æ®æ¸¸æˆç±»å‹å’Œç½‘ç»œç¯å¢ƒè°ƒæ•´ï¼Œå®æ—¶æ¸¸æˆé€šå¸¸è®¾ç½®ä¸º3-5ç§’
- ğŸ“Œ è¶…æ—¶æ—¶é—´è®¾ç½®ï¼šè¶…æ—¶æ—¶é—´é€šå¸¸è®¾ç½®ä¸ºå¿ƒè·³é—´éš”çš„3å€å·¦å³ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„æ—¶é—´æ¥æ”¶å¿ƒè·³å“åº”
- ğŸ“Œ å¿ƒè·³åŒ…å¤§å°ï¼šå¿ƒè·³åŒ…åº”å°½é‡å°ï¼Œå‡å°‘ç½‘ç»œå¼€é”€ï¼Œé€šå¸¸åªåŒ…å«æ—¶é—´æˆ³å’Œåºåˆ—å·
- ğŸ“Œ é‡è¿ç­–ç•¥ï¼šä½¿ç”¨æŒ‡æ•°é€€é¿ç®—æ³•ï¼Œé¿å…é¢‘ç¹é‡è¿å¯¼è‡´çš„ç½‘ç»œæ‹¥å¡
- ğŸ“Œ çŠ¶æ€åŒæ­¥ï¼šé‡è¿æˆåŠŸåéœ€è¦åŒæ­¥æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿ç©å®¶ä¸ä¼šä¸¢å¤±è¿›åº¦

**ä¼˜åŒ–å»ºè®®**ï¼š
- ğŸš€ ç½‘ç»œçŠ¶æ€æ£€æµ‹ï¼šåœ¨é‡è¿å‰æ£€æµ‹ç½‘ç»œçŠ¶æ€ï¼Œé¿å…åœ¨æ— ç½‘ç»œçš„æƒ…å†µä¸‹å°è¯•é‡è¿
- ğŸš€ æ‰¹é‡é‡è¿ï¼šå½“å¤šä¸ªå®¢æˆ·ç«¯åŒæ—¶æ–­çº¿æ—¶ï¼ŒæœåŠ¡å™¨å¯ä»¥æ‰¹é‡å¤„ç†é‡è¿è¯·æ±‚
- ğŸš€ å¿ƒè·³åŒ…å‹ç¼©ï¼šå¯¹äºç§»åŠ¨ç½‘ç»œï¼Œå¯ä»¥è€ƒè™‘å‹ç¼©å¿ƒè·³åŒ…ä»¥å‡å°‘å¸¦å®½ä½¿ç”¨
- ğŸš€ è‡ªé€‚åº”å¿ƒè·³ï¼šæ ¹æ®ç½‘ç»œè´¨é‡åŠ¨æ€è°ƒæ•´å¿ƒè·³é—´éš”
- ğŸš€ åå°é‡è¿ï¼šåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œå¯ä»¥åœ¨åå°è¿›è¡Œé‡è¿å°è¯•ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ

**è·¨å¹³å°è€ƒé‡**ï¼š
- ä¸åŒå¹³å°çš„ç½‘ç»œç¯å¢ƒå·®å¼‚è¾ƒå¤§ï¼Œéœ€è¦é’ˆå¯¹ä¸åŒå¹³å°è°ƒæ•´å¿ƒè·³å‚æ•°
- ç§»åŠ¨å¹³å°çš„ç½‘ç»œåˆ‡æ¢ï¼ˆå¦‚WiFiåˆ°ç§»åŠ¨æ•°æ®ï¼‰éœ€è¦ç‰¹æ®Šå¤„ç†
- WebGLå¹³å°çš„ç½‘ç»œé™åˆ¶è¾ƒå¤šï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨WebSocketçš„å¿ƒè·³æœºåˆ¶
- æ§åˆ¶å°å¹³å°çš„ç½‘ç»œç¨³å®šæ€§è¾ƒå¥½ï¼Œå¯ä»¥é€‚å½“å»¶é•¿å¿ƒè·³é—´éš”

**è®°å¿†è¦ç‚¹**ï¼š
- å¿ƒè·³æœºåˆ¶ï¼šå®šæœŸå‘é€å°æ•°æ®åŒ…æ£€æµ‹è¿æ¥çŠ¶æ€
- æ–­çº¿æ£€æµ‹ï¼šé€šè¿‡å¿ƒè·³è¶…æ—¶åˆ¤æ–­è¿æ¥æ˜¯å¦æ–­å¼€
- é‡è¿ç­–ç•¥ï¼šä½¿ç”¨æŒ‡æ•°é€€é¿ç®—æ³•ï¼Œé¿å…é¢‘ç¹é‡è¿
- çŠ¶æ€åŒæ­¥ï¼šé‡è¿åç¡®ä¿æ¸¸æˆçŠ¶æ€çš„ä¸€è‡´æ€§
- ç½‘ç»œé€‚åº”æ€§ï¼šæ ¹æ®ä¸åŒç½‘ç»œç¯å¢ƒè°ƒæ•´å‚æ•°

### 4. å®ç°åŸç†
**åº•å±‚å®ç°**ï¼š
- **å¿ƒè·³åŒ…ä¼ è¾“**ï¼šä½¿ç”¨TCPæˆ–UDPå‘é€å°æ•°æ®åŒ…
- **å®šæ—¶å™¨**ï¼šä½¿ç”¨å®šæ—¶å™¨å®šæœŸå‘é€å¿ƒè·³åŒ…å’Œæ£€æµ‹è¶…æ—¶
- **çŠ¶æ€ç®¡ç†**ï¼šç»´æŠ¤è¿æ¥çŠ¶æ€ï¼ŒåŒ…æ‹¬æœ€åå‘é€å’Œæ¥æ”¶å¿ƒè·³çš„æ—¶é—´
- **é‡è¿é€»è¾‘**ï¼šå®ç°é‡è¿å°è¯•ã€å»¶è¿Ÿå’Œæ¬¡æ•°é™åˆ¶

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š
```
// å¿ƒè·³åŒ…ç»“æ„
+----------------+----------------+
| æ—¶é—´æˆ³ (4B)    | åºåˆ—å· (2B)    |
+----------------+----------------+

// è¿æ¥çŠ¶æ€
class ConnectionState {
    bool isConnected;
    float lastHeartbeatSent;
    float lastHeartbeatReceived;
    int reconnectAttempts;
    float reconnectDelay;
}

// æ¶ˆæ¯é˜Ÿåˆ—
Queue<string> pendingMessages; // é‡è¿åéœ€è¦å‘é€çš„æ¶ˆæ¯
```

**æ ¸å¿ƒé€»è¾‘æµç¨‹**ï¼š
1. **å¿ƒè·³å‘é€**ï¼š
   - å®šæœŸå‘é€å¿ƒè·³åŒ…ï¼ŒåŒ…å«æ—¶é—´æˆ³å’Œåºåˆ—å·
   - æ›´æ–°æœ€åå‘é€å¿ƒè·³çš„æ—¶é—´

2. **å¿ƒè·³æ¥æ”¶**ï¼š
   - æ¥æ”¶å¹¶è§£æå¿ƒè·³åŒ…
   - æ›´æ–°æœ€åæ¥æ”¶å¿ƒè·³çš„æ—¶é—´
   - å›å¤å¿ƒè·³å“åº”ï¼ˆå¯é€‰ï¼‰

3. **æ–­çº¿æ£€æµ‹**ï¼š
   - æ£€æŸ¥æœ€åæ¥æ”¶å¿ƒè·³çš„æ—¶é—´æ˜¯å¦è¶…è¿‡è¶…æ—¶é˜ˆå€¼
   - å¦‚æœè¶…æ—¶ï¼Œæ ‡è®°è¿æ¥ä¸ºæ–­å¼€çŠ¶æ€

4. **é‡è¿å¤„ç†**ï¼š
   - å°è¯•é‡æ–°å»ºç«‹è¿æ¥
   - ä½¿ç”¨æŒ‡æ•°é€€é¿ç®—æ³•è°ƒæ•´é‡è¿å»¶è¿Ÿ
   - é™åˆ¶é‡è¿æ¬¡æ•°

5. **çŠ¶æ€åŒæ­¥**ï¼š
   - é‡è¿æˆåŠŸåï¼Œå‘é€ç§¯ç´¯çš„æ¶ˆæ¯
   - åŒæ­¥æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿ä¸€è‡´æ€§

### 5. çŸ¥è¯†ç‚¹æ€»ç»“
**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- å¿ƒè·³æœºåˆ¶ï¼šé€šè¿‡å®šæœŸå‘é€å°æ•°æ®åŒ…æ£€æµ‹è¿æ¥çŠ¶æ€
- æ–­çº¿æ£€æµ‹ï¼šåŸºäºå¿ƒè·³è¶…æ—¶åˆ¤æ–­è¿æ¥æ˜¯å¦æ–­å¼€
- é‡è¿ç­–ç•¥ï¼šå®ç°è‡ªåŠ¨é‡è¿ï¼Œç¡®ä¿è¿æ¥çš„ç¨³å®šæ€§
- æŒ‡æ•°é€€é¿ï¼šé€æ¸å¢åŠ é‡è¿å»¶è¿Ÿï¼Œé¿å…ç½‘ç»œæ‹¥å¡
- çŠ¶æ€åŒæ­¥ï¼šé‡è¿åç¡®ä¿æ¸¸æˆçŠ¶æ€çš„ä¸€è‡´æ€§

**æŠ€æœ¯è¦ç‚¹**ï¼š
- å¿ƒè·³é—´éš”å’Œè¶…æ—¶æ—¶é—´çš„è®¾ç½®åŸåˆ™
- å¿ƒè·³åŒ…çš„è®¾è®¡å’Œå®ç°
- æ–­çº¿æ£€æµ‹çš„é€»è¾‘å’Œè§¦å‘æ¡ä»¶
- é‡è¿ç­–ç•¥çš„é€‰æ‹©å’Œå®ç°
- é‡è¿æˆåŠŸåçš„çŠ¶æ€åŒæ­¥æœºåˆ¶

**åº”ç”¨åœºæ™¯**ï¼š
- å®æ—¶å¤šäººæ¸¸æˆï¼šä¿æŒé•¿è¿æ¥ï¼ŒåŠæ—¶æ£€æµ‹æ–­çº¿
- ç§»åŠ¨æ¸¸æˆï¼šåº”å¯¹ç½‘ç»œåˆ‡æ¢å’Œä¸ç¨³å®šçš„æƒ…å†µ
- åœ¨çº¿æœåŠ¡ï¼šç¡®ä¿æœåŠ¡çš„å¯ç”¨æ€§å’Œç¨³å®šæ€§
- ä»»ä½•éœ€è¦ä¿æŒé•¿è¿æ¥çš„åº”ç”¨

**å­¦ä¹ å»ºè®®**ï¼š
- æ·±å…¥ç†è§£ç½‘ç»œåè®®çš„è¿æ¥ç®¡ç†æœºåˆ¶
- å­¦ä¹ ä¸åŒç½‘ç»œç¯å¢ƒä¸‹çš„å¿ƒè·³å‚æ•°è°ƒæ•´
- å®è·µç¼–å†™å®Œæ•´çš„å¿ƒè·³å’Œé‡è¿ä»£ç 
- æµ‹è¯•åœ¨ä¸åŒç½‘ç»œæ¡ä»¶ä¸‹çš„æ€§èƒ½å’Œå¯é æ€§
- äº†è§£æ¸¸æˆå¼€å‘ä¸­å¸¸ç”¨çš„ç½‘ç»œåº“çš„å¿ƒè·³å®ç°

**è¿›é˜¶è·¯å¾„**ï¼š
- å­¦ä¹ åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¿ƒè·³æœºåˆ¶
- ç ”ç©¶ç½‘ç»œæ‹¥å¡æ§åˆ¶å’Œæµé‡æ•´å½¢
- äº†è§£è¾¹ç¼˜è®¡ç®—å’Œäº‘æ¸¸æˆä¸­çš„è¿æ¥ç®¡ç†
- å­¦ä¹ ç½‘ç»œå®‰å…¨ä¸­çš„å¿ƒè·³æœºåˆ¶ï¼ˆå¦‚TLSå¿ƒè·³ï¼‰
- ç ”ç©¶5Gç½‘ç»œå¯¹æ¸¸æˆè¿æ¥ç®¡ç†çš„å½±å“

### 6. é¡¹ç›®å®è·µ
**é¡¹ç›®æ¡ˆä¾‹**ï¼š
- **å¤šäººåœ¨çº¿è§’è‰²æ‰®æ¼”æ¸¸æˆ**ï¼šä½¿ç”¨å¿ƒè·³æœºåˆ¶ä¿æŒç©å®¶è¿æ¥ï¼Œå®ç°æ— ç¼é‡è¿
- **ç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆ**ï¼šä½å»¶è¿Ÿå¿ƒè·³æ£€æµ‹ï¼Œç¡®ä¿å®æ—¶å¯¹æˆ˜çš„è¿ç»­æ€§
- **ç§»åŠ¨æ¸¸æˆ**ï¼šé€‚åº”ä¸ç¨³å®šçš„ç§»åŠ¨ç½‘ç»œï¼Œå®ç°æ™ºèƒ½é‡è¿
- **åœ¨çº¿èŠå¤©ç³»ç»Ÿ**ï¼šä¿æŒé•¿è¿æ¥ï¼ŒåŠæ—¶æ¨é€æ¶ˆæ¯

**å¼€å‘æµç¨‹**ï¼š
1. **éœ€æ±‚åˆ†æ**ï¼šç¡®å®šç½‘ç»œé€šä¿¡çš„å…·ä½“éœ€æ±‚å’Œåœºæ™¯
2. **å‚æ•°è®¾è®¡**ï¼šæ ¹æ®æ¸¸æˆç±»å‹å’Œç›®æ ‡å¹³å°è®¾è®¡å¿ƒè·³å‚æ•°
3. **å®ç°åŸå‹**ï¼šç¼–å†™åŸºæœ¬çš„å¿ƒè·³å’Œé‡è¿ä»£ç 
4. **æµ‹è¯•éªŒè¯**ï¼šåœ¨ä¸åŒç½‘ç»œæ¡ä»¶ä¸‹æµ‹è¯•å¯é æ€§å’Œæ€§èƒ½
5. **ä¼˜åŒ–è°ƒæ•´**ï¼šæ ¹æ®æµ‹è¯•ç»“æœä¼˜åŒ–å‚æ•°å’Œå®ç°
6. **é›†æˆä¸Šçº¿**ï¼šå°†å¿ƒè·³å’Œé‡è¿ç³»ç»Ÿé›†æˆåˆ°æ¸¸æˆä¸­å¹¶å‘å¸ƒ

**æœ€ä½³å®è·µ**ï¼š
- **å‚æ•°è°ƒä¼˜**ï¼šæ ¹æ®æ¸¸æˆç±»å‹å’Œç½‘ç»œç¯å¢ƒè°ƒæ•´å¿ƒè·³é—´éš”å’Œè¶…æ—¶æ—¶é—´
- **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½•
- **ç”¨æˆ·ä½“éªŒ**ï¼šé‡è¿è¿‡ç¨‹ä¸­æä¾›æ¸…æ™°çš„åé¦ˆï¼Œé¿å…ç”¨æˆ·å›°æƒ‘
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘å¿ƒè·³åŒ…çš„å¤§å°å’Œé¢‘ç‡ï¼Œé™ä½ç½‘ç»œå¼€é”€
- **å®‰å…¨æ€§**ï¼šå¿ƒè·³åŒ…ä¸­å¯ä»¥åŒ…å«ç®€å•çš„è®¤è¯ä¿¡æ¯ï¼Œé˜²æ­¢æ¶æ„è¿æ¥

### 7. ç½‘ç»œæœç´¢ç»“æœ
**ç›¸å…³èµ„æ–™**ï¼š
- æ¸¸æˆç½‘ç»œç¼–ç¨‹ç²¾è¦ - Glenn Fiedler
- TCP/IPåè®®è¯¦è§£ï¼ˆå·1ï¼šåè®®ï¼‰- ç†æŸ¥å¾·Â·å²è’‚æ–‡æ–¯
- Unityå®˜æ–¹ç½‘ç»œç¼–ç¨‹æ–‡æ¡£
- RFC 6521ï¼šTCP Keep-Aliveè¯¦è§£

**ä¿¡æ¯éªŒè¯**ï¼š
- å¿ƒè·³æœºåˆ¶æ˜¯ç½‘ç»œç¼–ç¨‹ä¸­çš„æ ‡å‡†å®è·µï¼Œå·²åœ¨å¤šä¸ªæƒå¨æ¥æºä¸­å¾—åˆ°éªŒè¯
- æŒ‡æ•°é€€é¿é‡è¿ç­–ç•¥æ˜¯å¤„ç†ç½‘ç»œä¸ç¨³å®šæƒ…å†µçš„æœ‰æ•ˆæ–¹æ³•
- ä»£ç ç¤ºä¾‹åŸºäºæ¸¸æˆå¼€å‘å®è·µå’Œç½‘ç»œç¼–ç¨‹æœ€ä½³å®è·µ

**æƒå¨æ¥æº**ï¼š
- IETF RFC 6521ï¼šhttps://tools.ietf.org/html/rfc6521
- Microsoft Docsï¼šhttps://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient
- Unity Documentationï¼šhttps://docs.unity3d.com/Manual/UNet.html
- Glenn Fiedlerçš„ç½‘ç»œç¼–ç¨‹æ–‡ç« ï¼šhttps://gafferongames.com/
