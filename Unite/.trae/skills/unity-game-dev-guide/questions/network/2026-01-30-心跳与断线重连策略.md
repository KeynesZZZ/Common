# 心跳与断线重连策略详解

## 1. 概述

在网络通信中，心跳机制和断线重连是确保连接可靠性的重要组成部分。心跳机制通过定期发送小数据包来检测连接状态，而断线重连则在连接断开时自动尝试重新建立连接。在Unity游戏开发中，这两个机制对于确保游戏网络连接的稳定性至关重要。本文将深入探讨心跳与断线重连策略的实现原理和最佳实践。

## 2. 心跳机制的基本概念

### 2.1 心跳机制的定义

心跳机制是一种通过定期发送小数据包来检测网络连接状态的机制。它的目的是确保通信双方都知道连接是否仍然有效，以及及时发现连接断开的情况。

### 2.2 心跳机制的作用

心跳机制的主要作用包括：

1. **检测连接状态**：定期检测连接是否仍然有效
2. **保持连接活跃**：防止网络设备（如NAT、防火墙）因超时而关闭连接
3. **及时发现断线**：在连接断开时及时发现，避免无效等待
4. **网络质量监测**：通过心跳包的往返时间（RTT）监测网络质量
5. **负载均衡**：在集群环境中，心跳可以用于检测服务器状态

### 2.3 心跳机制的工作原理

心跳机制的基本工作原理如下：

1. **发送方**：定期发送心跳包到接收方
2. **接收方**：接收心跳包，并发送响应包
3. **超时检测**：如果发送方在一定时间内没有收到响应，认为连接可能已断开
4. **重连处理**：如果检测到连接断开，触发断线重连机制

## 3. 心跳包的设计和实现

### 3.1 心跳包的设计原则

设计心跳包时应遵循以下原则：

1. **体积小**：心跳包应该尽可能小，减少网络开销
2. **结构简单**：心跳包的结构应该简单，便于解析
3. **包含必要信息**：心跳包应包含必要的信息，如时间戳、序列号等
4. **频率合理**：心跳包的发送频率应该合理，既不过于频繁增加网络负载，也不过于稀疏导致检测延迟

### 3.2 心跳包的结构

一个典型的心跳包结构如下：

| 字段 | 类型 | 长度 | 描述 |
|------|------|------|------|
| 类型 | 字节 | 1 | 消息类型（心跳包） |
| 时间戳 | 长整型 | 8 | 发送时间戳 |
| 序列号 | 整型 | 4 | 心跳包序列号 |
| 附加信息 | 可变 | 可变 | 可选的附加信息，如网络质量等 |

### 3.3 心跳包的实现

#### 客户端实现

```csharp
public class HeartbeatManager
{
    private TcpClient client;
    private NetworkStream stream;
    private Thread heartbeatThread;
    private bool isRunning;
    private int heartbeatInterval = 3000; // 3秒
    private int timeoutThreshold = 10000; // 10秒
    private long lastHeartbeatTime;
    private int heartbeatSequence = 0;
    
    public event Action OnDisconnected;
    
    public void Start(TcpClient tcpClient)
    {
        client = tcpClient;
        stream = client.GetStream();
        isRunning = true;
        
        // 启动心跳线程
        heartbeatThread = new Thread(SendHeartbeat);
        heartbeatThread.IsBackground = true;
        heartbeatThread.Start();
        
        lastHeartbeatTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    }
    
    private void SendHeartbeat()
    {
        while (isRunning)
        {
            try
            {
                // 检查是否超时
                long currentTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
                if (currentTime - lastHeartbeatTime > timeoutThreshold)
                {
                    Debug.LogWarning("Heartbeat timeout, connection may be lost");
                    OnDisconnected?.Invoke();
                    break;
                }
                
                // 发送心跳包
                SendHeartbeatPacket();
                
                // 等待指定间隔
                Thread.Sleep(heartbeatInterval);
            }
            catch (Exception e)
            {
                Debug.LogError("Heartbeat error: " + e.Message);
                OnDisconnected?.Invoke();
                break;
            }
        }
    }
    
    private void SendHeartbeatPacket()
    {
        // 构建心跳包
        byte[] heartbeatPacket = BuildHeartbeatPacket();
        
        // 发送心跳包
        stream.Write(heartbeatPacket, 0, heartbeatPacket.Length);
        stream.Flush();
        
        Debug.Log("Heartbeat sent, sequence: " + heartbeatSequence);
    }
    
    private byte[] BuildHeartbeatPacket()
    {
        // 心跳包结构：类型(1) + 时间戳(8) + 序列号(4)
        byte[] packet = new byte[13];
        
        // 消息类型：1表示心跳包
        packet[0] = 1;
        
        // 时间戳
        long timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        byte[] timestampBytes = BitConverter.GetBytes(timestamp);
        Buffer.BlockCopy(timestampBytes, 0, packet, 1, 8);
        
        // 序列号
        byte[] sequenceBytes = BitConverter.GetBytes(heartbeatSequence);
        Buffer.BlockCopy(sequenceBytes, 0, packet, 9, 4);
        
        // 增加序列号
        heartbeatSequence++;
        
        return packet;
    }
    
    public void HandleHeartbeatResponse(byte[] response)
    {
        // 更新最后心跳时间
        lastHeartbeatTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        Debug.Log("Heartbeat response received");
    }
    
    public void Stop()
    {
        isRunning = false;
        if (heartbeatThread != null && heartbeatThread.IsAlive)
        {
            heartbeatThread.Join(1000);
        }
    }
}
```

#### 服务器端实现

```csharp
public class HeartbeatHandler
{
    private Dictionary<TcpClient, HeartbeatInfo> clientHeartbeats = new Dictionary<TcpClient, HeartbeatInfo>();
    private Thread checkThread;
    private bool isRunning;
    private int checkInterval = 5000; // 5秒
    private int timeoutThreshold = 15000; // 15秒
    
    public event Action<TcpClient> OnClientTimeout;
    
    public void Start()
    {
        isRunning = true;
        
        // 启动检查线程
        checkThread = new Thread(CheckHeartbeats);
        checkThread.IsBackground = true;
        checkThread.Start();
    }
    
    public void AddClient(TcpClient client)
    {
        clientHeartbeats[client] = new HeartbeatInfo
        {
            lastHeartbeatTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
    }
    
    public void RemoveClient(TcpClient client)
    {
        if (clientHeartbeats.ContainsKey(client))
        {
            clientHeartbeats.Remove(client);
        }
    }
    
    public void HandleHeartbeat(TcpClient client, byte[] heartbeatData)
    {
        if (clientHeartbeats.ContainsKey(client))
        {
            // 更新心跳时间
            clientHeartbeats[client].lastHeartbeatTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            
            // 发送响应
            SendHeartbeatResponse(client);
        }
    }
    
    private void SendHeartbeatResponse(TcpClient client)
    {
        try
        {
            NetworkStream stream = client.GetStream();
            
            // 构建响应包
            byte[] response = new byte[1];
            response[0] = 2; // 2表示心跳响应
            
            // 发送响应
            stream.Write(response, 0, response.Length);
            stream.Flush();
        }
        catch (Exception e)
        {
            Console.WriteLine("Error sending heartbeat response: " + e.Message);
            OnClientTimeout?.Invoke(client);
        }
    }
    
    private void CheckHeartbeats()
    {
        while (isRunning)
        {
            try
            {
                long currentTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
                List<TcpClient> timeoutClients = new List<TcpClient>();
                
                // 检查所有客户端的心跳
                foreach (var kvp in clientHeartbeats)
                {
                    TcpClient client = kvp.Key;
                    HeartbeatInfo info = kvp.Value;
                    
                    if (currentTime - info.lastHeartbeatTime > timeoutThreshold)
                    {
                        Console.WriteLine("Client timeout detected: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
                        timeoutClients.Add(client);
                    }
                }
                
                // 处理超时客户端
                foreach (TcpClient client in timeoutClients)
                {
                    OnClientTimeout?.Invoke(client);
                    RemoveClient(client);
                }
                
                // 等待指定间隔
                Thread.Sleep(checkInterval);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error checking heartbeats: " + e.Message);
            }
        }
    }
    
    public void Stop()
    {
        isRunning = false;
        if (checkThread != null && checkThread.IsAlive)
        {
            checkThread.Join(1000);
        }
    }
    
    private class HeartbeatInfo
    {
        public long lastHeartbeatTime;
    }
}
```

### 3.4 心跳频率的选择

心跳频率的选择应考虑以下因素：

1. **网络环境**：不同网络环境的稳定性不同，心跳频率应适应网络环境
2. **电池消耗**：在移动设备上，过于频繁的心跳会增加电池消耗
3. **服务器负载**：过于频繁的心跳会增加服务器负载
4. **检测延迟**：心跳频率过低会导致检测断线的延迟增加

一般来说，心跳频率可以设置为3-30秒之间，具体取决于实际场景：

- **局域网**：3-5秒
- **互联网**：5-15秒
- **移动网络**：15-30秒

## 4. 断线检测的方法和实现

### 4.1 断线检测的方法

常见的断线检测方法包括：

1. **心跳超时检测**：基于心跳包的超时检测
2. **读写操作异常**：通过捕获网络读写操作的异常检测断线
3. **连接状态检查**：定期检查连接的状态
4. **网络状态监听**：监听系统网络状态变化

### 4.2 心跳超时检测的实现

心跳超时检测的实现步骤如下：

1. **发送心跳包**：定期发送心跳包
2. **记录发送时间**：记录每次发送心跳包的时间
3. **等待响应**：等待服务器的心跳响应
4. **检查超时**：如果超过一定时间没有收到响应，认为连接可能已断开
5. **确认断线**：可以通过多次尝试确认是否真的断线

### 4.3 读写操作异常检测

在网络读写操作中捕获异常也是检测断线的重要方法：

```csharp
try
{
    // 网络读写操作
    int bytesRead = stream.Read(buffer, 0, buffer.Length);
    if (bytesRead == 0)
    {
        // 连接已关闭
        HandleDisconnection();
    }
}
catch (SocketException ex)
{
    // 网络异常，可能已断线
    Console.WriteLine("Socket exception: " + ex.Message);
    HandleDisconnection();
}
catch (IOException ex)
{
    // IO异常，可能已断线
    Console.WriteLine("IO exception: " + ex.Message);
    HandleDisconnection();
}
```

### 4.4 网络状态监听

在移动设备上，可以监听系统网络状态的变化：

```csharp
// Unity中的网络状态监听
private void Start()
{
    UnityEngine.Networking.NetworkChange.NetworkAddressChanged += OnNetworkAddressChanged;
    UnityEngine.Networking.NetworkChange.NetworkReachabilityChanged += OnNetworkReachabilityChanged;
}

private void OnNetworkAddressChanged(object sender, EventArgs e)
{
    Debug.Log("Network address changed");
    CheckConnection();
}

private void OnNetworkReachabilityChanged(object sender, EventArgs e)
{
    NetworkReachability reachability = Application.internetReachability;
    Debug.Log("Network reachability changed: " + reachability);
    
    if (reachability == NetworkReachability.NotReachable)
    {
        Debug.Log("Network not reachable");
        HandleDisconnection();
    }
}

private void OnDestroy()
{
    UnityEngine.Networking.NetworkChange.NetworkAddressChanged -= OnNetworkAddressChanged;
    UnityEngine.Networking.NetworkChange.NetworkReachabilityChanged -= OnNetworkReachabilityChanged;
}
```

## 5. 断线重连的策略和实现

### 5.1 断线重连的策略

常见的断线重连策略包括：

1. **立即重连**：一旦检测到断线，立即尝试重连
2. **延迟重连**：检测到断线后，延迟一段时间再尝试重连
3. **指数退避重连**：每次重连失败后，增加重连间隔时间
4. **最大尝试次数**：设置最大重连尝试次数，避免无限重连
5. **用户确认重连**：在某些情况下，需要用户确认后再重连

### 5.2 指数退避重连策略

指数退避重连是一种常用的重连策略，它的特点是：

1. **初始延迟**：第一次重连延迟较短
2. **指数增加**：每次重连失败后，延迟时间按指数增加
3. **最大延迟**：设置最大延迟时间，避免延迟过长
4. **随机抖动**：在延迟时间上添加随机抖动，避免多个客户端同时重连

### 5.3 断线重连的实现

#### 客户端重连实现

```csharp
public class ReconnectManager
{
    private string serverIP;
    private int serverPort;
    private TcpClient client;
    private NetworkStream stream;
    private Thread reconnectThread;
    private bool isReconnecting;
    private int maxAttempts = 10;
    private int attemptCount = 0;
    private int baseDelay = 1000; // 1秒
    private int maxDelay = 30000; // 30秒
    
    public event Action OnReconnectSuccess;
    public event Action OnReconnectFailed;
    
    public ReconnectManager(string ip, int port)
    {
        serverIP = ip;
        serverPort = port;
    }
    
    public void StartReconnect()
    {
        if (isReconnecting)
            return;
        
        attemptCount = 0;
        isReconnecting = true;
        
        reconnectThread = new Thread(AttemptReconnect);
        reconnectThread.IsBackground = true;
        reconnectThread.Start();
    }
    
    private void AttemptReconnect()
    {
        while (isReconnecting && attemptCount < maxAttempts)
        {
            attemptCount++;
            
            // 计算重连延迟（指数退避）
            int delay = Math.Min(baseDelay * (1 << (attemptCount - 1)), maxDelay);
            // 添加随机抖动
            delay = (int)(delay * (0.8 + UnityEngine.Random.value * 0.4));
            
            Debug.Log($"Attempting to reconnect ({attemptCount}/{maxAttempts}) after {delay}ms");
            
            // 等待延迟
            Thread.Sleep(delay);
            
            if (TryConnect())
            {
                // 重连成功
                Debug.Log("Reconnect successful");
                isReconnecting = false;
                OnReconnectSuccess?.Invoke();
                return;
            }
            else
            {
                Debug.LogWarning($"Reconnect attempt {attemptCount} failed");
            }
        }
        
        // 重连失败
        Debug.LogError("Reconnect failed after max attempts");
        isReconnecting = false;
        OnReconnectFailed?.Invoke();
    }
    
    private bool TryConnect()
    {
        try
        {
            // 关闭旧连接
            if (client != null && client.Connected)
            {
                client.Close();
            }
            
            // 创建新连接
            client = new TcpClient();
            client.Connect(serverIP, serverPort);
            stream = client.GetStream();
            
            // 连接成功
            return true;
        }
        catch (Exception e)
        {
            Debug.LogError("Connection error: " + e.Message);
            return false;
        }
    }
    
    public void StopReconnect()
    {
        isReconnecting = false;
        if (reconnectThread != null && reconnectThread.IsAlive)
        {
            reconnectThread.Join(1000);
        }
    }
    
    public TcpClient GetClient()
    {
        return client;
    }
    
    public NetworkStream GetStream()
    {
        return stream;
    }
}
```

#### 服务器端处理

服务器端需要处理客户端重连的情况，主要包括：

1. **客户端身份验证**：验证重连客户端的身份
2. **状态恢复**：恢复客户端的游戏状态
3. **资源清理**：清理客户端断开期间的资源

```csharp
public class ClientManager
{
    private Dictionary<TcpClient, ClientInfo> clients = new Dictionary<TcpClient, ClientInfo>();
    private Dictionary<string, ClientInfo> clientSessionMap = new Dictionary<string, ClientInfo>();
    
    public void HandleClientConnect(TcpClient client)
    {
        // 等待客户端发送身份信息
        // ...
    }
    
    public void HandleReconnect(string sessionId, TcpClient newClient)
    {
        if (clientSessionMap.TryGetValue(sessionId, out ClientInfo oldClientInfo))
        {
            // 找到旧客户端信息
            Console.WriteLine("Client reconnecting: " + sessionId);
            
            // 清理旧连接
            if (oldClientInfo.client != null && oldClientInfo.client.Connected)
            {
                try
                {
                    oldClientInfo.client.Close();
                }
                catch { }
            }
            
            // 更新客户端连接
            oldClientInfo.client = newClient;
            clients[newClient] = oldClientInfo;
            
            // 恢复客户端状态
            RestoreClientState(oldClientInfo);
            
            Console.WriteLine("Client reconnected successfully: " + sessionId);
        }
        else
        {
            // 会话不存在，可能是新连接
            Console.WriteLine("Session not found, treating as new connection: " + sessionId);
            // ...
        }
    }
    
    private void RestoreClientState(ClientInfo clientInfo)
    {
        // 恢复客户端游戏状态
        // ...
    }
    
    public void RemoveClient(TcpClient client)
    {
        if (clients.TryGetValue(client, out ClientInfo clientInfo))
        {
            // 从会话映射中移除
            if (!string.IsNullOrEmpty(clientInfo.sessionId))
            {
                clientSessionMap.Remove(clientInfo.sessionId);
            }
            
            // 从客户端列表中移除
            clients.Remove(client);
            
            Console.WriteLine("Client removed: " + clientInfo.sessionId);
        }
    }
    
    private class ClientInfo
    {
        public TcpClient client;
        public string sessionId;
        public GameState gameState;
        // 其他客户端信息
    }
}
```

## 6. Unity中的实现示例

### 6.1 完整的客户端实现

```csharp
using UnityEngine;
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading;

public class NetworkManager : MonoBehaviour
{
    private TcpClient client;
    private NetworkStream stream;
    private Thread receiveThread;
    private HeartbeatManager heartbeatManager;
    private ReconnectManager reconnectManager;
    private byte[] receiveBuffer = new byte[4096];
    private int receiveBufferSize = 0;
    
    public string serverIP = "127.0.0.1";
    public int serverPort = 8888;
    public bool isConnected = false;
    
    public event Action OnConnected;
    public event Action OnDisconnected;
    public event Action<string> OnMessageReceived;
    
    private void Start()
    {
        Connect();
    }
    
    public void Connect()
    {
        try
        {
            client = new TcpClient(serverIP, serverPort);
            stream = client.GetStream();
            isConnected = true;
            
            // 启动接收线程
            receiveThread = new Thread(ReceiveData);
            receiveThread.IsBackground = true;
            receiveThread.Start();
            
            // 初始化心跳管理器
            heartbeatManager = new HeartbeatManager();
            heartbeatManager.OnDisconnected += HandleDisconnection;
            heartbeatManager.Start(client);
            
            // 初始化重连管理器
            reconnectManager = new ReconnectManager(serverIP, serverPort);
            reconnectManager.OnReconnectSuccess += HandleReconnectSuccess;
            reconnectManager.OnReconnectFailed += HandleReconnectFailed;
            
            Debug.Log("Connected to server");
            OnConnected?.Invoke();
        }
        catch (Exception e)
        {
            Debug.LogError("Connection error: " + e.Message);
            HandleDisconnection();
        }
    }
    
    private void ReceiveData()
    {
        while (isConnected && client != null && client.Connected)
        {
            try
            {
                if (stream.DataAvailable)
                {
                    int bytesRead = stream.Read(receiveBuffer, receiveBufferSize, receiveBuffer.Length - receiveBufferSize);
                    receiveBufferSize += bytesRead;
                    ProcessBuffer();
                }
                else
                {
                    Thread.Sleep(10);
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Receive error: " + e.Message);
                HandleDisconnection();
                break;
            }
        }
    }
    
    private void ProcessBuffer()
    {
        // 处理接收到的数据
        // 这里需要根据实际的消息格式进行解析
        // ...
        
        // 示例：简单的消息处理
        if (receiveBufferSize > 0)
        {
            // 检查是否是心跳响应
            if (receiveBuffer[0] == 2)
            {
                // 处理心跳响应
                heartbeatManager.HandleHeartbeatResponse(receiveBuffer);
                receiveBufferSize = 0;
            }
            else
            {
                // 处理其他消息
                string message = Encoding.UTF8.GetString(receiveBuffer, 0, receiveBufferSize);
                Debug.Log("Received message: " + message);
                OnMessageReceived?.Invoke(message);
                receiveBufferSize = 0;
            }
        }
    }
    
    public void SendMessage(string message)
    {
        if (isConnected && stream != null && stream.CanWrite)
        {
            try
            {
                byte[] messageBytes = Encoding.UTF8.GetBytes(message);
                stream.Write(messageBytes, 0, messageBytes.Length);
                stream.Flush();
                Debug.Log("Sent message: " + message);
            }
            catch (Exception e)
            {
                Debug.LogError("Send error: " + e.Message);
                HandleDisconnection();
            }
        }
    }
    
    private void HandleDisconnection()
    {
        if (!isConnected)
            return;
        
        Debug.Log("Disconnected from server, starting reconnect");
        isConnected = false;
        
        // 清理资源
        if (heartbeatManager != null)
        {
            heartbeatManager.Stop();
        }
        
        if (stream != null)
        {
            try
            {
                stream.Close();
            }
            catch { }
        }
        
        if (client != null)
        {
            try
            {
                client.Close();
            }
            catch { }
        }
        
        OnDisconnected?.Invoke();
        
        // 开始重连
        reconnectManager.StartReconnect();
    }
    
    private void HandleReconnectSuccess()
    {
        Debug.Log("Reconnect successful");
        
        // 获取新连接
        client = reconnectManager.GetClient();
        stream = reconnectManager.GetStream();
        isConnected = true;
        
        // 重启接收线程
        receiveThread = new Thread(ReceiveData);
        receiveThread.IsBackground = true;
        receiveThread.Start();
        
        // 重启心跳
        heartbeatManager.Start(client);
        
        OnConnected?.Invoke();
    }
    
    private void HandleReconnectFailed()
    {
        Debug.LogError("Reconnect failed");
        // 处理重连失败的情况
        // 例如显示重连失败提示，让用户手动重试
    }
    
    private void OnApplicationQuit()
    {
        Disconnect();
    }
    
    public void Disconnect()
    {
        isConnected = false;
        
        if (heartbeatManager != null)
        {
            heartbeatManager.Stop();
        }
        
        if (reconnectManager != null)
        {
            reconnectManager.StopReconnect();
        }
        
        if (receiveThread != null && receiveThread.IsAlive)
        {
            receiveThread.Abort();
        }
        
        if (stream != null)
        {
            try
            {
                stream.Close();
            }
            catch { }
        }
        
        if (client != null)
        {
            try
            {
                client.Close();
            }
            catch { }
        }
        
        Debug.Log("Disconnected from server");
    }
}
```

### 6.2 服务器端实现

```csharp
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Collections.Generic;

public class TCPServer
{
    private TcpListener listener;
    private Thread listenThread;
    private Dictionary<TcpClient, ClientHandler> clients = new Dictionary<TcpClient, ClientHandler>();
    private HeartbeatHandler heartbeatHandler;
    private ClientManager clientManager;
    
    public int port = 8888;
    
    public void Start()
    {
        listener = new TcpListener(IPAddress.Any, port);
        listener.Start();
        
        listenThread = new Thread(ListenForClients);
        listenThread.IsBackground = true;
        listenThread.Start();
        
        // 初始化心跳处理器
        heartbeatHandler = new HeartbeatHandler();
        heartbeatHandler.OnClientTimeout += HandleClientTimeout;
        heartbeatHandler.Start();
        
        // 初始化客户端管理器
        clientManager = new ClientManager();
        
        Console.WriteLine("Server started on port " + port);
    }
    
    private void ListenForClients()
    {
        while (true)
        {
            try
            {
                TcpClient client = listener.AcceptTcpClient();
                Console.WriteLine("Client connected: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
                
                // 创建客户端处理器
                ClientHandler handler = new ClientHandler(client, this);
                clients[client] = handler;
                
                // 添加到心跳处理器
                heartbeatHandler.AddClient(client);
                
                // 启动客户端处理线程
                Thread clientThread = new Thread(handler.HandleClient);
                clientThread.IsBackground = true;
                clientThread.Start();
            }
            catch (Exception e)
            {
                Console.WriteLine("Error accepting client: " + e.Message);
                break;
            }
        }
    }
    
    public void RemoveClient(TcpClient client)
    {
        if (clients.TryGetValue(client, out ClientHandler handler))
        {
            handler.Stop();
            clients.Remove(client);
            heartbeatHandler.RemoveClient(client);
            clientManager.RemoveClient(client);
            Console.WriteLine("Client removed: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
        }
    }
    
    private void HandleClientTimeout(TcpClient client)
    {
        Console.WriteLine("Client timeout: " + ((IPEndPoint)client.Client.RemoteEndPoint).Address);
        RemoveClient(client);
    }
    
    public void HandleHeartbeat(TcpClient client, byte[] data)
    {
        heartbeatHandler.HandleHeartbeat(client, data);
    }
    
    public void HandleReconnect(TcpClient client, string sessionId)
    {
        clientManager.HandleReconnect(sessionId, client);
    }
    
    public void BroadcastMessage(string message)
    {
        byte[] messageBytes = Encoding.UTF8.GetBytes(message);
        
        foreach (var kvp in clients)
        {
            try
            {
                NetworkStream stream = kvp.Key.GetStream();
                stream.Write(messageBytes, 0, messageBytes.Length);
            }
            catch (Exception e)
            {
                Console.WriteLine("Error broadcasting to client: " + e.Message);
            }
        }
    }
    
    public void Stop()
    {
        // 停止所有客户端处理器
        foreach (var kvp in clients)
        {
            kvp.Value.Stop();
        }
        clients.Clear();
        
        // 停止心跳处理器
        if (heartbeatHandler != null)
        {
            heartbeatHandler.Stop();
        }
        
        // 停止监听线程
        if (listenThread != null && listenThread.IsAlive)
        {
            listenThread.Abort();
        }
        
        // 停止监听器
        if (listener != null)
        {
            listener.Stop();
        }
        
        Console.WriteLine("Server stopped");
    }
    
    private class ClientHandler
    {
        private TcpClient client;
        private NetworkStream stream;
        private TCPServer server;
        private byte[] buffer = new byte[4096];
        private bool isRunning;
        
        public ClientHandler(TcpClient tcpClient, TCPServer tcpServer)
        {
            client = tcpClient;
            server = tcpServer;
            stream = client.GetStream();
            isRunning = true;
        }
        
        public void HandleClient()
        {
            while (isRunning && client.Connected)
            {
                try
                {
                    if (stream.DataAvailable)
                    {
                        int bytesRead = stream.Read(buffer, 0, buffer.Length);
                        if (bytesRead > 0)
                        {
                            ProcessData(buffer, bytesRead);
                        }
                    }
                    else
                    {
                        Thread.Sleep(10);
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Client error: " + e.Message);
                    break;
                }
            }
            
            server.RemoveClient(client);
        }
        
        private void ProcessData(byte[] data, int length)
        {
            // 处理接收到的数据
            if (data[0] == 1)
            {
                // 心跳包
                server.HandleHeartbeat(client, data);
            }
            else if (data[0] == 3)
            {
                // 重连请求
                string sessionId = Encoding.UTF8.GetString(data, 1, length - 1);
                server.HandleReconnect(client, sessionId);
            }
            else
            {
                // 其他消息
                string message = Encoding.UTF8.GetString(data, 0, length);
                Console.WriteLine("Received message: " + message);
                // 处理消息...
            }
        }
        
        public void Stop()
        {
            isRunning = false;
            try
            {
                stream.Close();
                client.Close();
            }
            catch { }
        }
    }
}
```

## 7. 最佳实践和性能优化

### 7.1 心跳机制的最佳实践

1. **自适应心跳频率**：根据网络环境动态调整心跳频率
2. **心跳包压缩**：对于包含较多信息的心跳包，可以进行压缩
3. **批量处理**：将心跳包与其他消息批量发送，减少网络往返
4. **优先级处理**：心跳包应该有较高的处理优先级
5. **错误处理**：妥善处理心跳包的发送和接收错误

### 7.2 断线重连的最佳实践

1. **会话保持**：使用会话ID保持客户端身份，便于重连后恢复状态
2. **状态同步**：重连后需要同步客户端和服务器的状态
3. **重连提示**：在UI上显示重连状态，提升用户体验
4. **用户确认**：在某些情况下，需要用户确认后再重连
5. **网络切换**：在网络切换时（如从WiFi切换到移动网络），主动触发重连

### 7.3 性能优化策略

1. **减少心跳频率**：在网络稳定时减少心跳频率，节省带宽和电池
2. **使用UDP心跳**：对于心跳包，可以考虑使用UDP，减少TCP的开销
3. **连接池**：在服务器端使用连接池，减少连接创建的开销
4. **异步处理**：使用异步IO处理网络操作，提高并发性能
5. **内存优化**：减少内存分配和GC，特别是在心跳处理中

### 7.4 安全考虑

1. **心跳包加密**：对于包含敏感信息的心跳包，应该进行加密
2. **防止重放攻击**：使用时间戳和序列号防止重放攻击
3. **速率限制**：对心跳包的接收速率进行限制，防止DoS攻击
4. **认证信息**：在重连时需要进行身份认证，防止恶意重连

## 8. 常见问题与解决方案

### 8.1 心跳包丢失

**问题**：心跳包在网络传输中丢失，导致误判断线

**解决方案**：
- 设置合理的超时时间，允许一定的心跳包丢失
- 使用多次尝试确认断线
- 结合其他断线检测方法

### 8.2 重连失败

**问题**：客户端重连失败，无法恢复连接

**解决方案**：
- 使用指数退避重连策略
- 检查网络状态，在网络不可用时暂停重连
- 提供手动重连选项
- 记录重连失败的原因，便于调试

### 8.3 状态不同步

**问题**：重连后客户端和服务器状态不同步

**解决方案**：
- 在服务器端保存客户端状态
- 重连时进行状态同步
- 使用增量同步减少数据传输

### 8.4 服务器负载过高

**问题**：大量客户端同时重连导致服务器负载过高

**解决方案**：
- 在重连延迟中添加随机抖动
- 服务器端限制同时处理的重连请求数
- 使用队列处理重连请求

### 8.5 电池消耗过快

**问题**：过于频繁的心跳导致移动设备电池消耗过快

**解决方案**：
- 在移动网络下减少心跳频率
- 在设备休眠时调整心跳策略
- 使用系统的网络状态监听，在网络不可用时暂停心跳

## 9. 结论

心跳机制和断线重连策略是确保网络连接可靠性的重要组成部分。通过合理设计心跳包、实现高效的断线检测和重连机制，可以显著提高网络应用的稳定性和用户体验。

### 9.1 实现建议

1. **选择合适的心跳频率**：根据网络环境和应用场景选择合适的心跳频率
2. **实现完善的断线检测**：结合多种方法检测断线，提高检测的准确性
3. **采用指数退避重连**：使用指数退避策略进行重连，避免网络拥塞
4. **保持会话状态**：使用会话ID保持客户端身份，便于重连后恢复状态
5. **优化性能**：减少心跳开销，优化重连过程，提高系统性能
6. **考虑用户体验**：在重连过程中提供清晰的反馈，提升用户体验

### 9.2 未来发展

随着网络技术的发展，心跳和重连机制也在不断演进：

1. **智能心跳**：基于机器学习的智能心跳频率调整
2. **快速重连**：利用QUIC等协议的0-RTT特性实现快速重连
3. **边缘计算**：利用边缘节点减少重连延迟
4. **网络预测**：预测网络状态变化，提前准备重连

通过不断优化心跳和重连机制，可以构建更加可靠、高效的网络应用，为用户提供更好的体验。