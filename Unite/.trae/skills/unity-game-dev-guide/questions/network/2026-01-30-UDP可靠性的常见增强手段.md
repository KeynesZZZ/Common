# UDP可靠性的常见增强手段

## 1. 概述

UDP（User Datagram Protocol）是一种无连接的传输层协议，它提供了一种简单的、不可靠的数据传输服务。与TCP相比，UDP具有更低的延迟和更少的开销，因此在实时应用（如游戏、语音、视频）中得到广泛应用。然而，UDP的不可靠性也带来了一些问题，如数据包丢失、乱序、重复等。本文将探讨UDP可靠性的常见增强手段，以及如何在Unity中实现这些机制。

## 2. UDP的基本特点

### 2.1 UDP的优点

1. **低延迟**：UDP不需要建立连接，也没有拥塞控制和流量控制，因此延迟较低
2. **开销小**：UDP头部只有8字节，比TCP的20字节小很多
3. **灵活性高**：UDP允许应用程序自主控制数据传输的时机和方式
4. **支持多播**：UDP支持多播和广播，适合一对多通信

### 2.2 UDP的缺点

1. **不可靠**：UDP不保证数据包的到达，也不保证数据包的顺序
2. **无流量控制**：UDP不进行流量控制，可能导致接收方过载
3. **无拥塞控制**：UDP不进行拥塞控制，可能导致网络拥塞
4. **数据边界不保留**：UDP不保证数据的边界，可能出现数据包合并或拆分

### 2.3 可靠性增强的必要性

在实时应用中，虽然UDP的低延迟很重要，但完全的不可靠性也会影响应用的质量。例如，在游戏中，关键的游戏状态更新如果丢失，可能会导致游戏状态不一致；在语音通话中，过多的数据包丢失会影响语音质量。因此，需要在UDP的基础上增加一些可靠性机制，以平衡延迟和可靠性。

## 3. 常见的UDP可靠性增强手段

### 3.1 确认机制（ACK）

确认机制是最基本的可靠性增强手段，它通过接收方发送确认消息来通知发送方数据包已成功接收。

#### 实现原理

1. **发送方**：发送数据包时，为每个数据包分配一个唯一的序列号，并将数据包加入待确认队列
2. **接收方**：接收数据包后，发送一个包含该数据包序列号的确认消息（ACK）
3. **发送方**：收到ACK后，从待确认队列中移除对应的数据包

#### 代码示例

```csharp
// 发送方发送数据包
public void SendPacket(byte[] data)
{
    int sequenceNumber = GetNextSequenceNumber();
    byte[] packet = BuildPacket(data, sequenceNumber);
    udpClient.Send(packet, packet.Length, remoteEndPoint);
    pendingPackets.Add(sequenceNumber, new PendingPacket { Data = packet, Timestamp = DateTime.Now, RetryCount = 0 });
}

// 接收方处理数据包并发送ACK
private void ProcessReceivedPacket(byte[] data)
{
    int sequenceNumber = ExtractSequenceNumber(data);
    // 处理数据包内容
    ProcessPacketData(data);
    // 发送ACK
    SendAck(sequenceNumber);
}

// 发送方处理ACK
private void ProcessAck(int sequenceNumber)
{
    pendingPackets.Remove(sequenceNumber);
}
```

### 3.2 超时重传机制

超时重传机制是在确认机制的基础上，通过设置超时时间来检测数据包是否丢失，并在超时后重新发送数据包。

#### 实现原理

1. **设置超时时间**：为每个发送的数据包设置一个超时时间
2. **检测超时**：定期检查待确认队列中的数据包是否超时
3. **重新发送**：对超时的数据包进行重新发送
4. **最大重试次数**：设置最大重试次数，避免无限重传

#### 代码示例

```csharp
// 检查超时数据包
private void CheckTimeoutPackets()
{
    List<int> timeoutSequences = new List<int>();
    DateTime now = DateTime.Now;
    
    foreach (var kvp in pendingPackets)
    {
        int sequenceNumber = kvp.Key;
        PendingPacket packet = kvp.Value;
        
        // 检查是否超时
        if ((now - packet.Timestamp).TotalMilliseconds > timeoutThreshold)
        {
            if (packet.RetryCount < maxRetries)
            {
                // 重新发送
                udpClient.Send(packet.Data, packet.Data.Length, remoteEndPoint);
                packet.Timestamp = now;
                packet.RetryCount++;
                pendingPackets[sequenceNumber] = packet;
                Debug.Log($"Retransmitting packet {sequenceNumber}, retry count: {packet.RetryCount}");
            }
            else
            {
                // 达到最大重试次数，放弃
                timeoutSequences.Add(sequenceNumber);
                Debug.LogWarning($"Packet {sequenceNumber} failed after {maxRetries} retries");
            }
        }
    }
    
    // 移除达到最大重试次数的数据包
    foreach (int sequenceNumber in timeoutSequences)
    {
        pendingPackets.Remove(sequenceNumber);
    }
}
```

### 3.3 序列号机制

序列号机制用于解决数据包乱序和重复的问题。

#### 实现原理

1. **分配序列号**：为每个数据包分配一个递增的序列号
2. **接收方排序**：接收方根据序列号对数据包进行排序
3. **去重处理**：接收方根据已收到的最大序列号来过滤重复的数据包

#### 代码示例

```csharp
// 接收方处理数据包
private void ProcessReceivedPacket(byte[] data)
{
    int sequenceNumber = ExtractSequenceNumber(data);
    
    // 检查是否是重复数据包
    if (sequenceNumber <= lastReceivedSequenceNumber)
    {
        Debug.LogWarning($"Duplicate packet received: {sequenceNumber}");
        return;
    }
    
    // 检查是否是连续的数据包
    if (sequenceNumber == lastReceivedSequenceNumber + 1)
    {
        // 连续数据包，直接处理
        ProcessPacketData(data);
        lastReceivedSequenceNumber = sequenceNumber;
        // 检查是否有等待的数据包可以处理
        ProcessPendingOrderedPackets();
    }
    else
    {
        // 乱序数据包，加入等待队列
        pendingOrderedPackets[sequenceNumber] = data;
        Debug.LogWarning($"Out-of-order packet received: {sequenceNumber}, expected: {lastReceivedSequenceNumber + 1}");
    }
    
    // 发送ACK
    SendAck(sequenceNumber);
}

// 处理等待的有序数据包
private void ProcessPendingOrderedPackets()
{
    while (pendingOrderedPackets.ContainsKey(lastReceivedSequenceNumber + 1))
    {
        int nextSequenceNumber = lastReceivedSequenceNumber + 1;
        byte[] data = pendingOrderedPackets[nextSequenceNumber];
        ProcessPacketData(data);
        lastReceivedSequenceNumber = nextSequenceNumber;
        pendingOrderedPackets.Remove(nextSequenceNumber);
    }
}
```

### 3.4 滑动窗口机制

滑动窗口机制是一种流量控制机制，它通过限制同时在传输中的数据包数量来避免网络拥塞和接收方过载。

#### 实现原理

1. **窗口大小**：设置一个窗口大小，表示最多可以同时发送的未确认数据包数量
2. **发送窗口**：发送方维护一个发送窗口，只有窗口内的数据包可以发送
3. **接收窗口**：接收方维护一个接收窗口，只有窗口内的数据包可以接收
4. **窗口滑动**：当收到ACK时，发送窗口向前滑动；当处理完数据包时，接收窗口向前滑动

#### 代码示例

```csharp
// 发送方发送数据包（考虑滑动窗口）
public bool SendPacket(byte[] data)
{
    // 检查窗口是否已满
    if (pendingPackets.Count >= windowSize)
    {
        Debug.LogWarning("Send window full, packet queued");
        sendQueue.Enqueue(data);
        return false;
    }
    
    int sequenceNumber = GetNextSequenceNumber();
    byte[] packet = BuildPacket(data, sequenceNumber);
    udpClient.Send(packet, packet.Length, remoteEndPoint);
    pendingPackets.Add(sequenceNumber, new PendingPacket { Data = packet, Timestamp = DateTime.Now, RetryCount = 0 });
    return true;
}

// 处理ACK（滑动窗口）
private void ProcessAck(int sequenceNumber)
{
    pendingPackets.Remove(sequenceNumber);
    
    // 检查发送队列是否有等待发送的数据包
    while (sendQueue.Count > 0 && pendingPackets.Count < windowSize)
    {
        byte[] data = sendQueue.Dequeue();
        SendPacket(data);
    }
}
```

### 3.5 拥塞控制

拥塞控制用于避免网络拥塞，它通过监测网络状态来调整发送速率。

#### 实现原理

1. **网络状态监测**：通过数据包的往返时间（RTT）和丢包率来监测网络状态
2. **发送速率调整**：根据网络状态调整发送速率
3. **慢启动**：初始时发送速率较低，然后逐渐增加
4. **拥塞避免**：当检测到网络拥塞时，降低发送速率

#### 代码示例

```csharp
// 计算RTT
private void UpdateRTT(int sequenceNumber)
{
    if (pendingPackets.TryGetValue(sequenceNumber, out PendingPacket packet))
    {
        double rtt = (DateTime.Now - packet.Timestamp).TotalMilliseconds;
        smoothedRTT = (smoothedRTT * 0.8) + (rtt * 0.2);
        rttVariance = (rttVariance * 0.8) + (Math.Abs(rtt - smoothedRTT) * 0.2);
        timeoutThreshold = smoothedRTT + (4 * rttVariance);
    }
}

// 拥塞控制
private void UpdateSendRate()
{
    if (detectedCongestion)
    {
        // 检测到拥塞，降低发送速率
        sendRate = sendRate * 0.5;
        detectedCongestion = false;
    }
    else if (pendingPackets.Count == 0 && sendQueue.Count == 0)
    {
        // 网络空闲，增加发送速率
        sendRate = Math.Min(sendRate * 1.1, maxSendRate);
    }
}
```

### 3.6 前向纠错（FEC）

前向纠错是一种在发送端添加冗余信息的方法，接收端可以通过这些冗余信息恢复丢失的数据包，而不需要重新发送。

#### 实现原理

1. **发送方**：将原始数据包分成多个块，然后生成冗余块
2. **接收方**：接收数据包和冗余块，如果有数据包丢失，可以通过冗余块恢复

#### 代码示例

```csharp
// 发送方发送数据包和冗余块
public void SendWithFEC(List<byte[]> dataPackets)
{
    // 生成冗余块
    List<byte[]> redundantPackets = GenerateRedundantPackets(dataPackets);
    
    // 发送原始数据包
    foreach (byte[] packet in dataPackets)
    {
        SendPacket(packet);
    }
    
    // 发送冗余块
    foreach (byte[] redundantPacket in redundantPackets)
    {
        SendPacket(redundantPacket);
    }
}

// 接收方恢复丢失的数据包
private List<byte[]> RecoverLostPackets(List<byte[]> receivedPackets, int expectedCount)
{
    if (receivedPackets.Count >= expectedCount)
    {
        // 没有丢失数据包，直接返回
        return receivedPackets;
    }
    
    // 使用FEC恢复丢失的数据包
    List<byte[]> recoveredPackets = FEC.Recover(receivedPackets, expectedCount);
    return recoveredPackets;
}
```

### 3.7 混合可靠性模式

在实际应用中，通常会根据数据的重要性采用不同的可靠性模式。

#### 实现原理

1. **可靠传输**：对于关键数据（如游戏状态更新），使用确认和重传机制
2. **不可靠传输**：对于非关键数据（如位置更新），不使用确认和重传机制
3. **部分可靠传输**：对于时间敏感的数据（如语音），使用有限的重传次数

#### 代码示例

```csharp
// 根据数据类型选择传输模式
public void SendData(byte[] data, TransmissionMode mode)
{
    switch (mode)
    {
        case TransmissionMode.Reliable:
            // 可靠传输，使用确认和重传
            SendReliablePacket(data);
            break;
        case TransmissionMode.Unreliable:
            // 不可靠传输，直接发送
            SendUnreliablePacket(data);
            break;
        case TransmissionMode.PartiallyReliable:
            // 部分可靠传输，使用有限重传
            SendPartiallyReliablePacket(data);
            break;
    }
}

// 可靠传输
private void SendReliablePacket(byte[] data)
{
    // 使用确认和重传机制
    // ...
}

// 不可靠传输
private void SendUnreliablePacket(byte[] data)
{
    // 直接发送，不使用确认和重传
    udpClient.Send(data, data.Length, remoteEndPoint);
}

// 部分可靠传输
private void SendPartiallyReliablePacket(byte[] data)
{
    // 使用有限的重传次数
    // ...
}
```

## 4. Unity中的UDP可靠性增强实现

### 4.1 完整的UDP客户端实现

以下是一个在Unity中实现的完整UDP客户端，包含了确认机制、超时重传、序列号和滑动窗口等可靠性增强手段。

```csharp
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Text;

public class ReliableUDPClient : MonoBehaviour
{
    private UdpClient udpClient;
    private IPEndPoint remoteEndPoint;
    private Thread receiveThread;
    private bool isRunning;
    
    // 序列号管理
    private int nextSequenceNumber = 0;
    private int lastReceivedSequenceNumber = -1;
    
    // 待确认数据包
    private Dictionary<int, PendingPacket> pendingPackets = new Dictionary<int, PendingPacket>();
    
    // 等待处理的有序数据包
    private Dictionary<int, byte[]> pendingOrderedPackets = new Dictionary<int, byte[]>();
    
    // 发送队列
    private Queue<byte[]> sendQueue = new Queue<byte[]>();
    
    // 配置参数
    public string serverIP = "127.0.0.1";
    public int serverPort = 8888;
    public int windowSize = 16;
    public int maxRetries = 3;
    public int timeoutThreshold = 1000; // 1秒
    
    // 统计信息
    private int packetsSent = 0;
    private int packetsReceived = 0;
    private int packetsLost = 0;
    private int packetsRetransmitted = 0;
    
    // 事件
    public event Action<byte[]> OnDataReceived;
    
    private void Start()
    {
        Connect();
    }
    
    public void Connect()
    {
        try
        {
            remoteEndPoint = new IPEndPoint(IPAddress.Parse(serverIP), serverPort);
            udpClient = new UdpClient();
            udpClient.Client.ReceiveTimeout = 100;
            
            isRunning = true;
            receiveThread = new Thread(ReceiveData);
            receiveThread.IsBackground = true;
            receiveThread.Start();
            
            Debug.Log("Reliable UDP client connected to " + serverIP + ":" + serverPort);
        }
        catch (Exception e)
        {
            Debug.LogError("Error connecting: " + e.Message);
        }
    }
    
    private void Update()
    {
        // 检查超时数据包
        CheckTimeoutPackets();
        
        // 处理发送队列
        ProcessSendQueue();
    }
    
    public void Send(byte[] data)
    {
        if (pendingPackets.Count < windowSize)
        {
            SendReliablePacket(data);
        }
        else
        {
            sendQueue.Enqueue(data);
        }
    }
    
    private void SendReliablePacket(byte[] data)
    {
        int sequenceNumber = GetNextSequenceNumber();
        byte[] packet = BuildPacket(data, sequenceNumber);
        
        try
        {
            udpClient.Send(packet, packet.Length, remoteEndPoint);
            pendingPackets.Add(sequenceNumber, new PendingPacket
            {
                Data = packet,
                Timestamp = DateTime.Now,
                RetryCount = 0
            });
            packetsSent++;
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending packet: " + e.Message);
        }
    }
    
    private void SendUnreliablePacket(byte[] data)
    {
        try
        {
            udpClient.Send(data, data.Length, remoteEndPoint);
            packetsSent++;
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending unreliable packet: " + e.Message);
        }
    }
    
    private void SendAck(int sequenceNumber)
    {
        byte[] ackPacket = BuildAckPacket(sequenceNumber);
        try
        {
            udpClient.Send(ackPacket, ackPacket.Length, remoteEndPoint);
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending ACK: " + e.Message);
        }
    }
    
    private void ReceiveData()
    {
        while (isRunning)
        {
            try
            {
                IPEndPoint senderEndPoint = new IPEndPoint(IPAddress.Any, 0);
                byte[] data = udpClient.Receive(ref senderEndPoint);
                
                if (data.Length > 0)
                {
                    ProcessReceivedData(data);
                }
            }
            catch (SocketException ex)
            {
                // 忽略接收超时异常
                if (ex.SocketErrorCode != SocketError.TimedOut)
                {
                    Debug.LogError("Receive error: " + ex.Message);
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Receive error: " + e.Message);
            }
        }
    }
    
    private void ProcessReceivedData(byte[] data)
    {
        if (data.Length < 1)
            return;
        
        byte packetType = data[0];
        
        switch (packetType)
        {
            case 0x00: // 数据 packet
                ProcessDataPacket(data);
                break;
            case 0x01: // ACK packet
                ProcessAckPacket(data);
                break;
            default:
                Debug.LogWarning("Unknown packet type: " + packetType);
                break;
        }
    }
    
    private void ProcessDataPacket(byte[] data)
    {
        if (data.Length < 5) // 1 byte type + 4 bytes sequence number
            return;
        
        int sequenceNumber = BitConverter.ToInt32(data, 1);
        byte[] payload = new byte[data.Length - 5];
        Array.Copy(data, 5, payload, 0, payload.Length);
        
        // 检查是否是重复数据包
        if (sequenceNumber <= lastReceivedSequenceNumber)
        {
            Debug.LogWarning($"Duplicate packet received: {sequenceNumber}");
            return;
        }
        
        // 检查是否是连续的数据包
        if (sequenceNumber == lastReceivedSequenceNumber + 1)
        {
            // 连续数据包，直接处理
            ProcessPayload(payload);
            lastReceivedSequenceNumber = sequenceNumber;
            // 检查是否有等待的数据包可以处理
            ProcessPendingOrderedPackets();
        }
        else
        {
            // 乱序数据包，加入等待队列
            pendingOrderedPackets[sequenceNumber] = payload;
            Debug.LogWarning($"Out-of-order packet received: {sequenceNumber}, expected: {lastReceivedSequenceNumber + 1}");
        }
        
        // 发送ACK
        SendAck(sequenceNumber);
    }
    
    private void ProcessAckPacket(byte[] data)
    {
        if (data.Length < 5) // 1 byte type + 4 bytes sequence number
            return;
        
        int sequenceNumber = BitConverter.ToInt32(data, 1);
        
        if (pendingPackets.Remove(sequenceNumber))
        {
            packetsReceived++;
        }
    }
    
    private void ProcessPayload(byte[] payload)
    {
        OnDataReceived?.Invoke(payload);
    }
    
    private void ProcessPendingOrderedPackets()
    {
        while (pendingOrderedPackets.ContainsKey(lastReceivedSequenceNumber + 1))
        {
            int nextSequenceNumber = lastReceivedSequenceNumber + 1;
            byte[] payload = pendingOrderedPackets[nextSequenceNumber];
            ProcessPayload(payload);
            lastReceivedSequenceNumber = nextSequenceNumber;
            pendingOrderedPackets.Remove(nextSequenceNumber);
        }
    }
    
    private void CheckTimeoutPackets()
    {
        List<int> timeoutSequences = new List<int>();
        DateTime now = DateTime.Now;
        
        foreach (var kvp in pendingPackets)
        {
            int sequenceNumber = kvp.Key;
            PendingPacket packet = kvp.Value;
            
            // 检查是否超时
            if ((now - packet.Timestamp).TotalMilliseconds > timeoutThreshold)
            {
                if (packet.RetryCount < maxRetries)
                {
                    // 重新发送
                    try
                    {
                        udpClient.Send(packet.Data, packet.Data.Length, remoteEndPoint);
                        packet.Timestamp = now;
                        packet.RetryCount++;
                        pendingPackets[sequenceNumber] = packet;
                        packetsRetransmitted++;
                        Debug.Log($"Retransmitting packet {sequenceNumber}, retry count: {packet.RetryCount}");
                    }
                    catch (Exception e)
                    {
                        Debug.LogError("Error retransmitting packet: " + e.Message);
                    }
                }
                else
                {
                    // 达到最大重试次数，放弃
                    timeoutSequences.Add(sequenceNumber);
                    packetsLost++;
                    Debug.LogWarning($"Packet {sequenceNumber} failed after {maxRetries} retries");
                }
            }
        }
        
        // 移除达到最大重试次数的数据包
        foreach (int sequenceNumber in timeoutSequences)
        {
            pendingPackets.Remove(sequenceNumber);
        }
    }
    
    private void ProcessSendQueue()
    {
        while (sendQueue.Count > 0 && pendingPackets.Count < windowSize)
        {
            byte[] data = sendQueue.Dequeue();
            SendReliablePacket(data);
        }
    }
    
    private int GetNextSequenceNumber()
    {
        return nextSequenceNumber++;
    }
    
    private byte[] BuildPacket(byte[] data, int sequenceNumber)
    {
        byte[] packet = new byte[data.Length + 5];
        packet[0] = 0x00; // 数据 packet 类型
        Buffer.BlockCopy(BitConverter.GetBytes(sequenceNumber), 0, packet, 1, 4);
        Buffer.BlockCopy(data, 0, packet, 5, data.Length);
        return packet;
    }
    
    private byte[] BuildAckPacket(int sequenceNumber)
    {
        byte[] packet = new byte[5];
        packet[0] = 0x01; // ACK packet 类型
        Buffer.BlockCopy(BitConverter.GetBytes(sequenceNumber), 0, packet, 1, 4);
        return packet;
    }
    
    private void OnApplicationQuit()
    {
        Disconnect();
    }
    
    public void Disconnect()
    {
        isRunning = false;
        
        if (receiveThread != null && receiveThread.IsAlive)
        {
            receiveThread.Join(1000);
        }
        
        if (udpClient != null)
        {
            udpClient.Close();
        }
        
        Debug.Log("Reliable UDP client disconnected");
        Debug.Log($"Statistics: Sent={packetsSent}, Received={packetsReceived}, Lost={packetsLost}, Retransmitted={packetsRetransmitted}");
    }
    
    private class PendingPacket
    {
        public byte[] Data;
        public DateTime Timestamp;
        public int RetryCount;
    }
}
```

### 4.2 完整的UDP服务器实现

以下是一个在Unity中实现的完整UDP服务器，包含了确认机制、超时重传、序列号和滑动窗口等可靠性增强手段。

```csharp
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Text;

public class ReliableUDPServer : MonoBehaviour
{
    private UdpClient udpClient;
    private Thread listenThread;
    private bool isRunning;
    
    // 客户端信息
    private Dictionary<IPEndPoint, ClientInfo> clients = new Dictionary<IPEndPoint, ClientInfo>();
    
    // 配置参数
    public int port = 8888;
    public int windowSize = 16;
    public int maxRetries = 3;
    public int timeoutThreshold = 1000; // 1秒
    public int clientTimeout = 30000; // 30秒
    
    // 统计信息
    private int packetsSent = 0;
    private int packetsReceived = 0;
    private int packetsLost = 0;
    private int packetsRetransmitted = 0;
    
    // 事件
    public event Action<IPEndPoint, byte[]> OnDataReceived;
    
    private void Start()
    {
        StartServer();
    }
    
    public void StartServer()
    {
        try
        {
            udpClient = new UdpClient(port);
            udpClient.Client.ReceiveTimeout = 100;
            
            isRunning = true;
            listenThread = new Thread(ListenForClients);
            listenThread.IsBackground = true;
            listenThread.Start();
            
            Debug.Log("Reliable UDP server started on port " + port);
        }
        catch (Exception e)
        {
            Debug.LogError("Error starting server: " + e.Message);
        }
    }
    
    private void Update()
    {
        // 检查客户端超时
        CheckClientTimeout();
        
        // 检查超时数据包
        CheckTimeoutPackets();
    }
    
    private void ListenForClients()
    {
        while (isRunning)
        {
            try
            {
                IPEndPoint clientEndPoint = new IPEndPoint(IPAddress.Any, 0);
                byte[] data = udpClient.Receive(ref clientEndPoint);
                
                if (data.Length > 0)
                {
                    // 处理客户端数据
                    ProcessClientData(clientEndPoint, data);
                }
            }
            catch (SocketException ex)
            {
                // 忽略接收超时异常
                if (ex.SocketErrorCode != SocketError.TimedOut)
                {
                    Debug.LogError("Listen error: " + ex.Message);
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Listen error: " + e.Message);
            }
        }
    }
    
    private void ProcessClientData(IPEndPoint clientEndPoint, byte[] data)
    {
        // 获取或创建客户端信息
        ClientInfo clientInfo = GetOrCreateClientInfo(clientEndPoint);
        clientInfo.LastActivityTime = DateTime.Now;
        
        if (data.Length < 1)
            return;
        
        byte packetType = data[0];
        
        switch (packetType)
        {
            case 0x00: // 数据 packet
                ProcessDataPacket(clientInfo, data);
                break;
            case 0x01: // ACK packet
                ProcessAckPacket(clientInfo, data);
                break;
            default:
                Debug.LogWarning("Unknown packet type: " + packetType);
                break;
        }
    }
    
    private void ProcessDataPacket(ClientInfo clientInfo, byte[] data)
    {
        if (data.Length < 5) // 1 byte type + 4 bytes sequence number
            return;
        
        int sequenceNumber = BitConverter.ToInt32(data, 1);
        byte[] payload = new byte[data.Length - 5];
        Array.Copy(data, 5, payload, 0, payload.Length);
        
        // 检查是否是重复数据包
        if (sequenceNumber <= clientInfo.LastReceivedSequenceNumber)
        {
            Debug.LogWarning($"Duplicate packet received from {clientInfo.EndPoint}: {sequenceNumber}");
            return;
        }
        
        // 检查是否是连续的数据包
        if (sequenceNumber == clientInfo.LastReceivedSequenceNumber + 1)
        {
            // 连续数据包，直接处理
            ProcessPayload(clientInfo.EndPoint, payload);
            clientInfo.LastReceivedSequenceNumber = sequenceNumber;
            // 检查是否有等待的数据包可以处理
            ProcessPendingOrderedPackets(clientInfo);
        }
        else
        {
            // 乱序数据包，加入等待队列
            clientInfo.PendingOrderedPackets[sequenceNumber] = payload;
            Debug.LogWarning($"Out-of-order packet received from {clientInfo.EndPoint}: {sequenceNumber}, expected: {clientInfo.LastReceivedSequenceNumber + 1}");
        }
        
        // 发送ACK
        SendAck(clientInfo, sequenceNumber);
    }
    
    private void ProcessAckPacket(ClientInfo clientInfo, byte[] data)
    {
        if (data.Length < 5) // 1 byte type + 4 bytes sequence number
            return;
        
        int sequenceNumber = BitConverter.ToInt32(data, 1);
        
        if (clientInfo.PendingPackets.Remove(sequenceNumber))
        {
            packetsReceived++;
        }
    }
    
    private void ProcessPayload(IPEndPoint endPoint, byte[] payload)
    {
        OnDataReceived?.Invoke(endPoint, payload);
    }
    
    private void ProcessPendingOrderedPackets(ClientInfo clientInfo)
    {
        while (clientInfo.PendingOrderedPackets.ContainsKey(clientInfo.LastReceivedSequenceNumber + 1))
        {
            int nextSequenceNumber = clientInfo.LastReceivedSequenceNumber + 1;
            byte[] payload = clientInfo.PendingOrderedPackets[nextSequenceNumber];
            ProcessPayload(clientInfo.EndPoint, payload);
            clientInfo.LastReceivedSequenceNumber = nextSequenceNumber;
            clientInfo.PendingOrderedPackets.Remove(nextSequenceNumber);
        }
    }
    
    public void Send(IPEndPoint endPoint, byte[] data)
    {
        ClientInfo clientInfo = GetOrCreateClientInfo(endPoint);
        
        if (clientInfo.PendingPackets.Count < windowSize)
        {
            SendReliablePacket(clientInfo, data);
        }
        else
        {
            clientInfo.SendQueue.Enqueue(data);
        }
    }
    
    private void SendReliablePacket(ClientInfo clientInfo, byte[] data)
    {
        int sequenceNumber = clientInfo.GetNextSequenceNumber();
        byte[] packet = BuildPacket(data, sequenceNumber);
        
        try
        {
            udpClient.Send(packet, packet.Length, clientInfo.EndPoint);
            clientInfo.PendingPackets.Add(sequenceNumber, new PendingPacket
            {
                Data = packet,
                Timestamp = DateTime.Now,
                RetryCount = 0
            });
            packetsSent++;
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending packet: " + e.Message);
        }
    }
    
    private void SendUnreliablePacket(IPEndPoint endPoint, byte[] data)
    {
        try
        {
            udpClient.Send(data, data.Length, endPoint);
            packetsSent++;
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending unreliable packet: " + e.Message);
        }
    }
    
    private void SendAck(ClientInfo clientInfo, int sequenceNumber)
    {
        byte[] ackPacket = BuildAckPacket(sequenceNumber);
        try
        {
            udpClient.Send(ackPacket, ackPacket.Length, clientInfo.EndPoint);
        }
        catch (Exception e)
        {
            Debug.LogError("Error sending ACK: " + e.Message);
        }
    }
    
    private void CheckTimeoutPackets()
    {
        DateTime now = DateTime.Now;
        
        foreach (ClientInfo clientInfo in clients.Values)
        {
            List<int> timeoutSequences = new List<int>();
            
            foreach (var kvp in clientInfo.PendingPackets)
            {
                int sequenceNumber = kvp.Key;
                PendingPacket packet = kvp.Value;
                
                // 检查是否超时
                if ((now - packet.Timestamp).TotalMilliseconds > timeoutThreshold)
                {
                    if (packet.RetryCount < maxRetries)
                    {
                        // 重新发送
                        try
                        {
                            udpClient.Send(packet.Data, packet.Data.Length, clientInfo.EndPoint);
                            packet.Timestamp = now;
                            packet.RetryCount++;
                            clientInfo.PendingPackets[sequenceNumber] = packet;
                            packetsRetransmitted++;
                            Debug.Log($"Retransmitting packet {sequenceNumber} to {clientInfo.EndPoint}, retry count: {packet.RetryCount}");
                        }
                        catch (Exception e)
                        {
                            Debug.LogError("Error retransmitting packet: " + e.Message);
                        }
                    }
                    else
                    {
                        // 达到最大重试次数，放弃
                        timeoutSequences.Add(sequenceNumber);
                        packetsLost++;
                        Debug.LogWarning($"Packet {sequenceNumber} to {clientInfo.EndPoint} failed after {maxRetries} retries");
                    }
                }
            }
            
            // 移除达到最大重试次数的数据包
            foreach (int sequenceNumber in timeoutSequences)
            {
                clientInfo.PendingPackets.Remove(sequenceNumber);
            }
            
            // 处理发送队列
            ProcessSendQueue(clientInfo);
        }
    }
    
    private void ProcessSendQueue(ClientInfo clientInfo)
    {
        while (clientInfo.SendQueue.Count > 0 && clientInfo.PendingPackets.Count < windowSize)
        {
            byte[] data = clientInfo.SendQueue.Dequeue();
            SendReliablePacket(clientInfo, data);
        }
    }
    
    private void CheckClientTimeout()
    {
        List<IPEndPoint> timeoutClients = new List<IPEndPoint>();
        DateTime now = DateTime.Now;
        
        foreach (var kvp in clients)
        {
            IPEndPoint endPoint = kvp.Key;
            ClientInfo clientInfo = kvp.Value;
            
            if ((now - clientInfo.LastActivityTime).TotalMilliseconds > clientTimeout)
            {
                timeoutClients.Add(endPoint);
                Debug.LogWarning($"Client {endPoint} timed out");
            }
        }
        
        // 移除超时客户端
        foreach (IPEndPoint endPoint in timeoutClients)
        {
            clients.Remove(endPoint);
        }
    }
    
    private ClientInfo GetOrCreateClientInfo(IPEndPoint endPoint)
    {
        if (!clients.TryGetValue(endPoint, out ClientInfo clientInfo))
        {
            clientInfo = new ClientInfo(endPoint);
            clients[endPoint] = clientInfo;
            Debug.Log("New client connected: " + endPoint);
        }
        
        return clientInfo;
    }
    
    private byte[] BuildPacket(byte[] data, int sequenceNumber)
    {
        byte[] packet = new byte[data.Length + 5];
        packet[0] = 0x00; // 数据 packet 类型
        Buffer.BlockCopy(BitConverter.GetBytes(sequenceNumber), 0, packet, 1, 4);
        Buffer.BlockCopy(data, 0, packet, 5, data.Length);
        return packet;
    }
    
    private byte[] BuildAckPacket(int sequenceNumber)
    {
        byte[] packet = new byte[5];
        packet[0] = 0x01; // ACK packet 类型
        Buffer.BlockCopy(BitConverter.GetBytes(sequenceNumber), 0, packet, 1, 4);
        return packet;
    }
    
    private void OnApplicationQuit()
    {
        StopServer();
    }
    
    public void StopServer()
    {
        isRunning = false;
        
        if (listenThread != null && listenThread.IsAlive)
        {
            listenThread.Join(1000);
        }
        
        if (udpClient != null)
        {
            udpClient.Close();
        }
        
        Debug.Log("Reliable UDP server stopped");
        Debug.Log($"Statistics: Sent={packetsSent}, Received={packetsReceived}, Lost={packetsLost}, Retransmitted={packetsRetransmitted}");
    }
    
    private class ClientInfo
    {
        public IPEndPoint EndPoint;
        public int NextSequenceNumber = 0;
        public int LastReceivedSequenceNumber = -1;
        public Dictionary<int, PendingPacket> PendingPackets = new Dictionary<int, PendingPacket>();
        public Dictionary<int, byte[]> PendingOrderedPackets = new Dictionary<int, byte[]>();
        public Queue<byte[]> SendQueue = new Queue<byte[]>();
        public DateTime LastActivityTime = DateTime.Now;
        
        public ClientInfo(IPEndPoint endPoint)
        {
            EndPoint = endPoint;
        }
        
        public int GetNextSequenceNumber()
        {
            return NextSequenceNumber++;
        }
    }
    
    private class PendingPacket
    {
        public byte[] Data;
        public DateTime Timestamp;
        public int RetryCount;
    }
}
```

## 5. 最佳实践和性能优化

### 5.1 最佳实践

1. **根据数据类型选择传输模式**：
   - 关键数据（如游戏状态更新）：使用可靠传输
   - 实时数据（如位置更新）：使用不可靠传输
   - 时间敏感数据（如语音）：使用部分可靠传输

2. **合理设置参数**：
   - 窗口大小：根据网络带宽和延迟设置，一般为16-64
   - 超时阈值：根据网络延迟设置，一般为100-1000毫秒
   - 最大重试次数：根据应用需求设置，一般为3-5次

3. **实现流量控制**：
   - 使用滑动窗口控制并发传输的数据包数量
   - 根据网络状态动态调整发送速率

4. **优化数据包大小**：
   - 尽量减小数据包大小，避免IP分片
   - 合并多个小数据包为一个大数据包发送

5. **处理网络切换**：
   - 监听网络状态变化，在网络切换时重新建立连接
   - 在网络不可用时暂停发送，避免不必要的重传

### 5.2 性能优化策略

1. **使用对象池**：
   - 为数据包和缓冲区使用对象池，减少GC
   - 避免频繁创建和销毁网络相关对象

2. **多线程处理**：
   - 使用专门的线程处理网络IO，避免阻塞主线程
   - 使用线程池处理并发任务

3. **批处理**：
   - 批量发送ACK，减少网络往返
   - 批量处理待确认数据包

4. **压缩数据**：
   - 对较大的数据包进行压缩，减少网络传输量
   - 使用高效的压缩算法，如LZ4

5. **硬件加速**：
   - 在支持的平台上使用硬件加速的网络API
   - 使用UDP的硬件校验和功能

### 5.3 安全考虑

1. **数据包加密**：
   - 对敏感数据进行加密，防止窃听
   - 使用安全的加密算法，如AES

2. **防重放攻击**：
   - 使用序列号和时间戳防止重放攻击
   - 维护已处理的序列号列表

3. **防DDoS攻击**：
   - 限制单个IP的连接数和数据包速率
   - 使用令牌桶算法进行流量控制

4. **认证和授权**：
   - 对客户端进行身份认证
   - 授权客户端只能访问其有权限的资源

## 6. 常见问题与解决方案

### 6.1 数据包丢失

**问题**：数据包在传输过程中丢失，导致重传次数增加，延迟增大。

**解决方案**：
1. **增加冗余**：使用前向纠错（FEC）增加冗余信息
2. **调整超时阈值**：根据网络状况动态调整超时阈值
3. **优化网络路径**：选择更稳定的网络路径
4. **减少数据包大小**：减小数据包大小，降低丢失概率

### 6.2 数据包乱序

**问题**：数据包到达顺序与发送顺序不一致，导致处理延迟。

**解决方案**：
1. **使用序列号**：为每个数据包分配序列号，接收方根据序列号排序
2. **实现滑动窗口**：使用滑动窗口机制处理乱序数据包
3. **合理设置缓冲区**：设置足够大的缓冲区来存储乱序数据包

### 6.3 网络拥塞

**问题**：网络拥塞导致数据包延迟和丢失增加。

**解决方案**：
1. **实现拥塞控制**：监测网络状态，调整发送速率
2. **使用流量整形**：平滑发送流量，避免突发流量
3. **优先级队列**：为重要数据包分配更高的优先级

### 6.4 高延迟

**问题**：网络延迟过高，影响实时应用的体验。

**解决方案**：
1. **选择合适的传输模式**：对实时数据使用不可靠传输
2. **优化网络协议**：减少协议 overhead，如使用更小的头部
3. **边缘计算**：使用边缘服务器减少网络路径长度
4. **预测和插值**：在客户端使用预测和插值技术，减少延迟对用户体验的影响

### 6.5 系统资源消耗

**问题**：UDP可靠性增强机制导致系统资源消耗增加。

**解决方案**：
1. **优化算法**：使用更高效的算法实现可靠性机制
2. **减少重传**：优化重传策略，减少不必要的重传
3. **资源限制**：设置合理的资源限制，如最大连接数、最大缓冲区大小
4. **硬件优化**：使用硬件加速的网络设备

## 7. 结论

UDP可靠性增强是在保持UDP低延迟特性的同时，提高其可靠性的重要手段。通过实现确认机制、超时重传、序列号、滑动窗口等机制，可以显著提高UDP的可靠性，使其更适合实时应用。

### 7.1 实现建议

1. **根据应用需求选择合适的可靠性机制**：不同的应用对可靠性和延迟的要求不同，应根据具体需求选择合适的可靠性机制。

2. **平衡延迟和可靠性**：在实现可靠性机制时，应注意平衡延迟和可靠性，避免过度追求可靠性而导致延迟增加。

3. **优化参数配置**：根据网络环境和应用场景，合理配置窗口大小、超时阈值、最大重试次数等参数。

4. **监控和调优**：实时监控网络状态和性能指标，根据实际情况调整可靠性机制的参数。

5. **持续改进**：随着网络技术的发展和应用需求的变化，不断改进和优化可靠性机制。

### 7.2 未来发展

随着5G、边缘计算等新技术的发展，UDP可靠性增强机制也在不断演进：

1. **智能拥塞控制**：使用机器学习算法预测网络状态，动态调整拥塞控制策略。

2. **多路径传输**：利用多路径传输技术，在多个网络路径上同时传输数据，提高可靠性和吞吐量。

3. **网络切片**：利用5G的网络切片技术，为不同应用分配专用的网络资源，提高传输质量。

4. **QUIC协议**：Google开发的QUIC协议结合了UDP的低延迟和TCP的可靠性，是未来网络传输的重要发展方向。

通过不断探索和创新，UDP可靠性增强机制将在实时应用中发挥越来越重要的作用，为用户提供更好的体验。