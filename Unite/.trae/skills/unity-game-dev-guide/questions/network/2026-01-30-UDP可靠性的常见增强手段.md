---
title: "UDPå¯é æ€§çš„å¸¸è§å¢å¼ºæ‰‹æ®µ"
date: "2026-01-30 11:00:00"
tags: [Unity, ç½‘ç»œç¼–ç¨‹, UDP, å¯é æ€§, æ¸¸æˆå¼€å‘]
difficulty: "ä¸­çº§"
topic: "ç½‘ç»œç¼–ç¨‹"
project: "å¤šäººåœ¨çº¿æ¸¸æˆ"
skill_level: "ä¸­çº§"
---

# UDPå¯é æ€§çš„å¸¸è§å¢å¼ºæ‰‹æ®µ

## é—®é¢˜æè¿°
> è¯·è¯¦ç»†è§£é‡ŠUDPå¯é æ€§çš„å¸¸è§å¢å¼ºæ‰‹æ®µï¼Œä»¥åŠåœ¨æ¸¸æˆå¼€å‘ä¸­å¦‚ä½•å®ç°è¿™äº›æœºåˆ¶ã€‚

## å›ç­”

### 1. é—®é¢˜åˆ†æ
**æŠ€æœ¯èƒŒæ™¯**ï¼š
- UDPï¼ˆUser Datagram Protocolï¼‰æ˜¯ä¸€ç§æ— è¿æ¥çš„ä¼ è¾“å±‚åè®®ï¼Œæä¾›ä¸å¯é çš„ã€æ— åºçš„æ•°æ®åŒ…ä¼ è¾“
- ä¸TCPç›¸æ¯”ï¼ŒUDPå…·æœ‰æ›´ä½çš„å»¶è¿Ÿå’Œå¼€é”€ï¼Œé€‚åˆå®æ—¶æ¸¸æˆç­‰å¯¹å»¶è¿Ÿæ•æ„Ÿçš„åœºæ™¯
- ç„¶è€Œï¼ŒUDPçš„ä¸å¯é æ€§ï¼ˆæ•°æ®åŒ…å¯èƒ½ä¸¢å¤±ã€é‡å¤ã€ä¹±åºï¼‰é™åˆ¶äº†å…¶åœ¨æŸäº›åœºæ™¯çš„åº”ç”¨
- æ¸¸æˆå¼€å‘ä¸­ï¼Œéœ€è¦åœ¨UDPçš„ä½å»¶è¿Ÿå’ŒTCPçš„å¯é æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹

**æ ¹æœ¬åŸå› **ï¼š
- UDPæœ¬èº«ä¸æä¾›å¯é æ€§ä¿éšœæœºåˆ¶
- ç½‘ç»œæ‹¥å¡ã€è·¯ç”±é—®é¢˜ã€å¸¦å®½é™åˆ¶ç­‰å› ç´ å¯èƒ½å¯¼è‡´æ•°æ®åŒ…ä¸¢å¤±
- æ•°æ®åŒ…åœ¨ç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­å¯èƒ½è¢«é‡å¤æˆ–ä¹±åº
- è¿™äº›é—®é¢˜åœ¨æ¸¸æˆä¸­å¯èƒ½å¯¼è‡´ç©å®¶æ“ä½œä¸åŒæ­¥ã€çŠ¶æ€ä¸ä¸€è‡´ç­‰é—®é¢˜

**è§£å†³æ–¹æ¡ˆæ¦‚è¿°**ï¼š
- å®ç°åºåˆ—å·æœºåˆ¶ï¼Œå¤„ç†æ•°æ®åŒ…ä¹±åºå’Œé‡å¤
- å®ç°ç¡®è®¤æœºåˆ¶ï¼ˆACKï¼‰ï¼Œæ£€æµ‹æ•°æ®åŒ…ä¸¢å¤±
- å®ç°é‡ä¼ æœºåˆ¶ï¼Œç¡®ä¿é‡è¦æ•°æ®åŒ…çš„å¯é ä¼ è¾“
- å®ç°æµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶
- æä¾›å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µ

**æŠ€æœ¯éš¾åº¦**ï¼šä¸­çº§
**é€‚ç”¨åœºæ™¯**ï¼šå®æ—¶å¤šäººæ¸¸æˆã€è¯­éŸ³é€šä¿¡ã€è§†é¢‘æµç­‰å¯¹å»¶è¿Ÿæ•æ„Ÿçš„åœºæ™¯
**å…³è”é¡¹ç›®**ï¼šç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆï¼ˆFPSï¼‰ã€å¤šäººåœ¨çº¿æˆ˜æ–— arenaï¼ˆMOBAï¼‰ã€å®æ—¶æˆ˜ç•¥æ¸¸æˆï¼ˆRTSï¼‰

### 2. æ¡ˆä¾‹æ¼”ç¤º

#### UDPå¯é æ€§å¢å¼ºæœºåˆ¶

**1. åºåˆ—å·æœºåˆ¶**
**å®ç°æ€è·¯**ï¼š
- ä¸ºæ¯ä¸ªå‘é€çš„æ•°æ®åŒ…åˆ†é…ä¸€ä¸ªé€’å¢çš„åºåˆ—å·
- æ¥æ”¶æ–¹æ ¹æ®åºåˆ—å·æ£€æµ‹é‡å¤æ•°æ®åŒ…å’Œä¹±åºæ•°æ®åŒ…
- å¯¹äºé‡å¤æ•°æ®åŒ…ç›´æ¥ä¸¢å¼ƒï¼Œå¯¹äºä¹±åºæ•°æ®åŒ…æ ¹æ®æƒ…å†µå¤„ç†

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
public class UDPPacket
{
    public ushort SequenceNumber { get; set; }
    public byte[] Data { get; set; }
    
    public UDPPacket(ushort sequenceNumber, byte[] data)
    {
        SequenceNumber = sequenceNumber;
        Data = data;
    }
    
    public byte[] Serialize()
    {
        byte[] packet = new byte[2 + Data.Length];
        Buffer.BlockCopy(BitConverter.GetBytes(SequenceNumber), 0, packet, 0, 2);
        Buffer.BlockCopy(Data, 0, packet, 2, Data.Length);
        return packet;
    }
    
    public static UDPPacket Deserialize(byte[] data)
    {
        ushort sequenceNumber = BitConverter.ToUInt16(data, 0);
        byte[] payload = new byte[data.Length - 2];
        Buffer.BlockCopy(data, 2, payload, 0, payload.Length);
        return new UDPPacket(sequenceNumber, payload);
    }
}

public class UDPReceiver
{
    private ushort lastReceivedSequence = 0;
    
    public void HandlePacket(UDPPacket packet)
    {
        // æ£€æµ‹é‡å¤æ•°æ®åŒ…
        if (packet.SequenceNumber <= lastReceivedSequence)
        {
            Debug.Log("Duplicate packet received, discarding: " + packet.SequenceNumber);
            return;
        }
        
        // æ£€æµ‹æ•°æ®åŒ…é—´éš”ï¼ˆå¯èƒ½æœ‰ä¸¢å¤±ï¼‰
        if (packet.SequenceNumber > lastReceivedSequence + 1)
        {
            int lostCount = packet.SequenceNumber - lastReceivedSequence - 1;
            Debug.Log("Packets lost: " + lostCount);
            // å¤„ç†æ•°æ®åŒ…ä¸¢å¤±çš„æƒ…å†µ
        }
        
        // å¤„ç†æ•°æ®åŒ…
        ProcessPacket(packet);
        
        // æ›´æ–°æœ€åæ¥æ”¶çš„åºåˆ—å·
        lastReceivedSequence = packet.SequenceNumber;
    }
    
    private void ProcessPacket(UDPPacket packet)
    {
        // å¤„ç†æ•°æ®åŒ…å†…å®¹
        Debug.Log("Processing packet: " + packet.SequenceNumber);
    }
}
```

**2. ç¡®è®¤æœºåˆ¶ï¼ˆACKï¼‰**
**å®ç°æ€è·¯**ï¼š
- æ¥æ”¶æ–¹æ”¶åˆ°æ•°æ®åŒ…åå‘é€ç¡®è®¤åŒ…ï¼ˆACKï¼‰
- å‘é€æ–¹ç»´æŠ¤ä¸€ä¸ªæœªç¡®è®¤æ•°æ®åŒ…çš„åˆ—è¡¨
- å¦‚æœåœ¨è¶…æ—¶æ—¶é—´å†…æœªæ”¶åˆ°ACKï¼Œè®¤ä¸ºæ•°æ®åŒ…ä¸¢å¤±

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
public class ACKPacket
{
    public ushort AcknowledgedSequence { get; set; }
    
    public ACKPacket(ushort acknowledgedSequence)
    {
        AcknowledgedSequence = acknowledgedSequence;
    }
    
    public byte[] Serialize()
    {
        return BitConverter.GetBytes(AcknowledgedSequence);
    }
    
    public static ACKPacket Deserialize(byte[] data)
    {
        return new ACKPacket(BitConverter.ToUInt16(data, 0));
    }
}

public class UDPSender
{
    private ushort nextSequenceNumber = 1;
    private Dictionary<ushort, PacketInfo> pendingPackets = new Dictionary<ushort, PacketInfo>();
    private const float ACKTimeout = 0.5f; // 500msè¶…æ—¶
    
    private class PacketInfo
    {
        public byte[] Data { get; set; }
        public float Timestamp { get; set; }
        public int RetryCount { get; set; }
        public const int MaxRetries = 3;
    }
    
    public void SendPacket(UdpClient client, IPEndPoint endPoint, byte[] data)
    {
        ushort sequence = nextSequenceNumber++;
        UDPPacket packet = new UDPPacket(sequence, data);
        byte[] serializedPacket = packet.Serialize();
        
        // å‘é€æ•°æ®åŒ…
        client.Send(serializedPacket, serializedPacket.Length, endPoint);
        
        // è®°å½•æœªç¡®è®¤çš„æ•°æ®åŒ…
        pendingPackets[sequence] = new PacketInfo
        {
            Data = data,
            Timestamp = Time.time,
            RetryCount = 0
        };
    }
    
    public void HandleACK(ushort acknowledgedSequence)
    {
        // ç§»é™¤å·²ç¡®è®¤çš„æ•°æ®åŒ…
        if (pendingPackets.ContainsKey(acknowledgedSequence))
        {
            pendingPackets.Remove(acknowledgedSequence);
        }
    }
    
    public void Update()
    {
        // æ£€æŸ¥è¶…æ—¶çš„æ•°æ®åŒ…
        List<ushort> toRemove = new List<ushort>();
        List<ushort> toRetry = new List<ushort>();
        
        foreach (var kvp in pendingPackets)
        {
            ushort sequence = kvp.Key;
            PacketInfo info = kvp.Value;
            
            if (Time.time - info.Timestamp > ACKTimeout)
            {
                if (info.RetryCount < PacketInfo.MaxRetries)
                {
                    // é‡ä¼ æ•°æ®åŒ…
                    toRetry.Add(sequence);
                    info.RetryCount++;
                    info.Timestamp = Time.time;
                }
                else
                {
                    // è¾¾åˆ°æœ€å¤§é‡ä¼ æ¬¡æ•°ï¼Œæ”¾å¼ƒ
                    toRemove.Add(sequence);
                    Debug.Log("Packet failed after max retries: " + sequence);
                }
            }
        }
        
        // ç§»é™¤å¤±è´¥çš„æ•°æ®åŒ…
        foreach (ushort sequence in toRemove)
        {
            pendingPackets.Remove(sequence);
        }
        
        // é‡ä¼ æ•°æ®åŒ…
        foreach (ushort sequence in toRetry)
        {
            if (pendingPackets.TryGetValue(sequence, out PacketInfo info))
            {
                // è¿™é‡Œéœ€è¦å®é™…çš„å‘é€é€»è¾‘
                Debug.Log("Retransmitting packet: " + sequence + " (attempt " + info.RetryCount + ")");
            }
        }
    }
}
```

**3. æµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶**
**å®ç°æ€è·¯**ï¼š
- åŸºäºæ¥æ”¶æ–¹çš„å¤„ç†èƒ½åŠ›è°ƒæ•´å‘é€é€Ÿç‡
- åŸºäºç½‘ç»œçŠ¶å†µè°ƒæ•´å‘é€é€Ÿç‡ï¼Œé¿å…ç½‘ç»œæ‹¥å¡
- ä½¿ç”¨æ»‘åŠ¨çª—å£æœºåˆ¶ç®¡ç†æœªç¡®è®¤çš„æ•°æ®åŒ…

**ä»£ç ç¤ºä¾‹**ï¼š
```csharp
public class UDPFlowControl
{
    private const int InitialWindowSize = 16; // åˆå§‹çª—å£å¤§å°
    private const int MaxWindowSize = 128;    // æœ€å¤§çª—å£å¤§å°
    private const int MinWindowSize = 4;      // æœ€å°çª—å£å¤§å°
    private const float CongestionThreshold = 0.8f; // æ‹¥å¡é˜ˆå€¼
    
    private int windowSize = InitialWindowSize;
    private float congestionLevel = 0f;
    private int packetLossCount = 0;
    private int totalPacketsSent = 0;
    
    public bool CanSendPacket()
    {
        // åŸºäºçª—å£å¤§å°åˆ¤æ–­æ˜¯å¦å¯ä»¥å‘é€æ•°æ®åŒ…
        return pendingPackets.Count < windowSize;
    }
    
    public void OnPacketSent()
    {
        totalPacketsSent++;
    }
    
    public void OnPacketLost()
    {
        packetLossCount++;
        // è®¡ç®—ä¸¢åŒ…ç‡
        float lossRate = (float)packetLossCount / totalPacketsSent;
        
        // è°ƒæ•´çª—å£å¤§å°
        if (lossRate > CongestionThreshold)
        {
            // ç½‘ç»œæ‹¥å¡ï¼Œå‡å°çª—å£å¤§å°
            windowSize = Mathf.Max(MinWindowSize, windowSize / 2);
            Debug.Log("Network congestion detected, reducing window size to: " + windowSize);
        }
    }
    
    public void OnPacketDelivered()
    {
        // ç½‘ç»œçŠ¶å†µè‰¯å¥½ï¼Œé€‚å½“å¢å¤§çª—å£å¤§å°
        if (windowSize < MaxWindowSize)
        {
            windowSize = Mathf.Min(MaxWindowSize, windowSize + 1);
        }
    }
    
    public void Reset()
    {
        windowSize = InitialWindowSize;
        congestionLevel = 0f;
        packetLossCount = 0;
        totalPacketsSent = 0;
    }
}
```

**4. å®Œæ•´çš„UDPå¯é ä¼ è¾“ç¤ºä¾‹**

**UDPClient**ï¼š
```csharp
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using UnityEngine;

public class ReliableUDPClient : MonoBehaviour
{
    private UdpClient client;
    private IPEndPoint serverEndPoint;
    private Thread receiveThread;
    private bool isRunning = false;
    
    private UDPSender sender;
    private UDPReceiver receiver;
    private UDPFlowControl flowControl;
    
    [SerializeField] private string serverIP = "127.0.0.1";
    [SerializeField] private int serverPort = 8888;
    [SerializeField] private int localPort = 8889;
    
    private void Start()
    {
        Initialize();
    }
    
    private void Initialize()
    {
        try
        {
            client = new UdpClient(localPort);
            serverEndPoint = new IPEndPoint(IPAddress.Parse(serverIP), serverPort);
            isRunning = true;
            
            sender = new UDPSender();
            receiver = new UDPReceiver();
            flowControl = new UDPFlowControl();
            
            receiveThread = new Thread(ReceivePackets);
            receiveThread.Start();
            
            Debug.Log("UDP client initialized successfully!");
        }
        catch (Exception e)
        {
            Debug.LogError("UDP client initialization error: " + e.Message);
        }
    }
    
    private void ReceivePackets()
    {
        while (isRunning)
        {
            try
            {
                IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                byte[] data = client.Receive(ref remoteEndPoint);
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ACKåŒ…
                if (data.Length == 2)
                {
                    ACKPacket ack = ACKPacket.Deserialize(data);
                    sender.HandleACK(ack.AcknowledgedSequence);
                    flowControl.OnPacketDelivered();
                }
                else
                {
                    // å¤„ç†æ™®é€šæ•°æ®åŒ…
                    UDPPacket packet = UDPPacket.Deserialize(data);
                    receiver.HandlePacket(packet);
                    
                    // å‘é€ACK
                    ACKPacket ack = new ACKPacket(packet.SequenceNumber);
                    client.Send(ack.Serialize(), ack.Serialize().Length, serverEndPoint);
                }
            }
            catch (Exception e)
            {
                Debug.LogError("Receive error: " + e.Message);
            }
        }
    }
    
    public void SendData(string message)
    {
        if (isRunning && flowControl.CanSendPacket())
        {
            byte[] data = Encoding.UTF8.GetBytes(message);
            sender.SendPacket(client, serverEndPoint, data);
            flowControl.OnPacketSent();
        }
    }
    
    private void Update()
    {
        if (isRunning)
        {
            sender.Update();
        }
    }
    
    private void OnApplicationQuit()
    {
        isRunning = false;
        if (receiveThread != null && receiveThread.IsAlive)
        {
            receiveThread.Abort();
        }
        if (client != null)
        {
            client.Close();
        }
    }
}
```

**UDPServer**ï¼š
```csharp
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

public class ReliableUDPServer
{
    private UdpClient server;
    private bool isRunning = false;
    private Thread listenThread;
    
    private Dictionary<IPEndPoint, ClientInfo> clients = new Dictionary<IPEndPoint, ClientInfo>();
    
    public class ClientInfo
    {
        public UDPSender Sender { get; set; }
        public UDPReceiver Receiver { get; set; }
        public UDPFlowControl FlowControl { get; set; }
        
        public ClientInfo()
        {
            Sender = new UDPSender();
            Receiver = new UDPReceiver();
            FlowControl = new UDPFlowControl();
        }
    }
    
    public void StartServer(int port)
    {
        try
        {
            server = new UdpClient(port);
            isRunning = true;
            
            listenThread = new Thread(ListenForPackets);
            listenThread.Start();
            
            Console.WriteLine("UDP server started on port " + port);
        }
        catch (Exception e)
        {
            Console.WriteLine("Server start error: " + e.Message);
        }
    }
    
    private void ListenForPackets()
    {
        while (isRunning)
        {
            try
            {
                IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                byte[] data = server.Receive(ref remoteEndPoint);
                
                // ç¡®ä¿å®¢æˆ·ç«¯ä¿¡æ¯å­˜åœ¨
                if (!clients.ContainsKey(remoteEndPoint))
                {
                    clients[remoteEndPoint] = new ClientInfo();
                    Console.WriteLine("Client connected: " + remoteEndPoint);
                }
                
                ClientInfo clientInfo = clients[remoteEndPoint];
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ACKåŒ…
                if (data.Length == 2)
                {
                    ACKPacket ack = ACKPacket.Deserialize(data);
                    clientInfo.Sender.HandleACK(ack.AcknowledgedSequence);
                    clientInfo.FlowControl.OnPacketDelivered();
                }
                else
                {
                    // å¤„ç†æ™®é€šæ•°æ®åŒ…
                    UDPPacket packet = UDPPacket.Deserialize(data);
                    clientInfo.Receiver.HandlePacket(packet);
                    
                    // å‘é€ACK
                    ACKPacket ack = new ACKPacket(packet.SequenceNumber);
                    server.Send(ack.Serialize(), ack.Serialize().Length, remoteEndPoint);
                    
                    // å›æ˜¾æ¶ˆæ¯
                    string message = Encoding.UTF8.GetString(packet.Data);
                    Console.WriteLine("Received from " + remoteEndPoint + ": " + message);
                    
                    if (clientInfo.FlowControl.CanSendPacket())
                    {
                        byte[] responseData = Encoding.UTF8.GetBytes("Server: " + message);
                        clientInfo.Sender.SendPacket(server, remoteEndPoint, responseData);
                        clientInfo.FlowControl.OnPacketSent();
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Listen error: " + e.Message);
            }
        }
    }
    
    public void Update()
    {
        // æ›´æ–°æ‰€æœ‰å®¢æˆ·ç«¯çš„å‘é€å™¨
        foreach (var clientInfo in clients.Values)
        {
            clientInfo.Sender.Update();
        }
    }
    
    public void StopServer()
    {
        isRunning = false;
        if (listenThread != null && listenThread.IsAlive)
        {
            listenThread.Abort();
        }
        if (server != null)
        {
            server.Close();
        }
    }
}
```

**å®ç°è¯´æ˜**ï¼š
- **åºåˆ—å·æœºåˆ¶**ï¼šä¸ºæ¯ä¸ªæ•°æ®åŒ…åˆ†é…é€’å¢çš„åºåˆ—å·ï¼Œå¤„ç†ä¹±åºå’Œé‡å¤
- **ç¡®è®¤æœºåˆ¶**ï¼šæ¥æ”¶æ–¹å‘é€ACKç¡®è®¤æ”¶åˆ°æ•°æ®åŒ…ï¼Œå‘é€æ–¹è·Ÿè¸ªæœªç¡®è®¤çš„æ•°æ®åŒ…
- **é‡ä¼ æœºåˆ¶**ï¼šå¯¹è¶…æ—¶æœªç¡®è®¤çš„æ•°æ®åŒ…è¿›è¡Œé‡ä¼ ï¼Œæœ€å¤šå°è¯•3æ¬¡
- **æµé‡æ§åˆ¶**ï¼šåŸºäºçª—å£å¤§å°æ§åˆ¶å‘é€é€Ÿç‡ï¼Œé¿å…ç½‘ç»œæ‹¥å¡
- **å®Œæ•´å®ç°**ï¼šæä¾›äº†å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯çš„å®Œæ•´ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•é›†æˆè¿™äº›æœºåˆ¶

### 3. æ³¨æ„äº‹é¡¹
**å…³é”®è¦ç‚¹**ï¼š
- ğŸ“Œ åºåˆ—å·çš„æº¢å‡ºå¤„ç†ï¼šåºåˆ—å·ä½¿ç”¨æ— ç¬¦å·æ•´æ•°ï¼Œéœ€è¦å¤„ç†æº¢å‡ºæƒ…å†µ
- ğŸ“Œ ç¡®è®¤æœºåˆ¶çš„å¼€é”€ï¼šé¢‘ç¹çš„ACKå¯èƒ½å¢åŠ ç½‘ç»œè´Ÿæ‹…ï¼Œéœ€è¦æƒè¡¡å¯é æ€§å’Œå¼€é”€
- ğŸ“Œ é‡ä¼ ç­–ç•¥ï¼šä¸åŒç±»å‹çš„æ•°æ®åŒ…å¯èƒ½éœ€è¦ä¸åŒçš„é‡ä¼ ç­–ç•¥
- ğŸ“Œ æµé‡æ§åˆ¶ï¼šè¿‡åº¦çš„æµé‡æ§åˆ¶å¯èƒ½å¯¼è‡´å»¶è¿Ÿå¢åŠ ï¼Œéœ€è¦æ‰¾åˆ°å¹³è¡¡ç‚¹
- ğŸ“Œ ä¼˜å…ˆçº§æœºåˆ¶ï¼šå¯¹é‡è¦æ•°æ®åŒ…ï¼ˆå¦‚ç©å®¶è¾“å…¥ï¼‰ç»™äºˆæ›´é«˜çš„ä¼˜å…ˆçº§

**ä¼˜åŒ–å»ºè®®**ï¼š
- ğŸš€ å·®å¼‚åŒ–å¯é æ€§ï¼šæ ¹æ®æ•°æ®åŒ…çš„é‡è¦æ€§æä¾›ä¸åŒçº§åˆ«çš„å¯é æ€§ä¿éšœ
- ğŸš€ æ‰¹é‡ç¡®è®¤ï¼šå°†å¤šä¸ªACKåˆå¹¶ä¸ºä¸€ä¸ªï¼Œå‡å°‘ç½‘ç»œå¼€é”€
- ğŸš€ é¢„æµ‹æœºåˆ¶ï¼šå¯¹äºå®æ—¶æ¸¸æˆï¼Œå¯ä»¥é¢„æµ‹ç©å®¶çš„ä¸‹ä¸€æ­¥æ“ä½œï¼Œå‡å°‘å»¶è¿Ÿå½±å“
- ğŸš€ å‹ç¼©æ•°æ®ï¼šä½¿ç”¨æ•°æ®å‹ç¼©å‡å°‘æ•°æ®åŒ…å¤§å°ï¼Œæé«˜ä¼ è¾“æ•ˆç‡
- ğŸš€ å¤šé€šé“ä¼ è¾“ï¼šå°†ä¸åŒç±»å‹çš„æ•°æ®ï¼ˆå¦‚è¾“å…¥ã€çŠ¶æ€ã€è¯­éŸ³ï¼‰åˆ†ç¦»åˆ°ä¸åŒçš„é€šé“

**è·¨å¹³å°è€ƒé‡**ï¼š
- ä¸åŒå¹³å°çš„UDPå®ç°å¯èƒ½æœ‰ç»†å¾®å·®åˆ«ï¼Œä½†åŸºæœ¬åŸç†ç›¸åŒ
- ç§»åŠ¨å¹³å°çš„ç½‘ç»œç¯å¢ƒä¸ç¨³å®šï¼Œéœ€è¦æ›´å¥å£®çš„é”™è¯¯å¤„ç†
- WebGLå¹³å°çš„UDPæ”¯æŒæœ‰é™ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨WebSocketæˆ–å…¶ä»–æ›¿ä»£æ–¹æ¡ˆ

**è®°å¿†è¦ç‚¹**ï¼š
- åºåˆ—å·ï¼šå¤„ç†ä¹±åºå’Œé‡å¤æ•°æ®åŒ…
- ç¡®è®¤æœºåˆ¶ï¼šæ£€æµ‹æ•°æ®åŒ…ä¸¢å¤±
- é‡ä¼ æœºåˆ¶ï¼šç¡®ä¿é‡è¦æ•°æ®åŒ…çš„ä¼ è¾“
- æµé‡æ§åˆ¶ï¼šé¿å…ç½‘ç»œæ‹¥å¡
- å·®å¼‚åŒ–å¯é æ€§ï¼šæ ¹æ®æ•°æ®é‡è¦æ€§è°ƒæ•´å¯é æ€§ç­–ç•¥

### 4. å®ç°åŸç†
**åº•å±‚å®ç°**ï¼š
- **åè®®æ ˆ**ï¼šåœ¨UDPä¹‹ä¸Šæ„å»ºå¯é ä¼ è¾“åè®®æ ˆ
- **çŠ¶æ€ç®¡ç†**ï¼šç»´æŠ¤å‘é€å’Œæ¥æ”¶çŠ¶æ€ï¼ŒåŒ…æ‹¬åºåˆ—å·ã€æœªç¡®è®¤æ•°æ®åŒ…ç­‰
- **å®šæ—¶å™¨**ï¼šä½¿ç”¨å®šæ—¶å™¨æ£€æµ‹è¶…æ—¶å’Œè§¦å‘é‡ä¼ 
- **ç¼“å†²åŒºç®¡ç†**ï¼šä½¿ç”¨ç¼“å†²åŒºå­˜å‚¨å¾…å‘é€å’Œå¾…å¤„ç†çš„æ•°æ®åŒ…

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š
```
// æ•°æ®åŒ…ç»“æ„
+----------------+----------------+----------------+
| åºåˆ—å· (2B)    | æ ‡å¿—ä½ (1B)    | æ•°æ®å†…å®¹ (nB)  |
+----------------+----------------+----------------+

// ACKåŒ…ç»“æ„
+----------------+
| ç¡®è®¤åºåˆ—å· (2B) |
+----------------+

// å‘é€çŠ¶æ€
Dictionary<ushort, PacketInfo> pendingPackets; // æœªç¡®è®¤çš„æ•°æ®åŒ…
ushort nextSequenceNumber; // ä¸‹ä¸€ä¸ªè¦å‘é€çš„åºåˆ—å·

// æ¥æ”¶çŠ¶æ€
ushort lastReceivedSequence; // æœ€åæ¥æ”¶çš„åºåˆ—å·
Queue<UDPPacket> outOfOrderPackets; // ä¹±åºæ•°æ®åŒ…é˜Ÿåˆ—
```

**æ ¸å¿ƒé€»è¾‘æµç¨‹**ï¼š
1. **å‘é€æµç¨‹**ï¼š
   - åˆ†é…åºåˆ—å·
   - æ„å»ºæ•°æ®åŒ…
   - å‘é€æ•°æ®åŒ…
   - è®°å½•æœªç¡®è®¤çš„æ•°æ®åŒ…
   - å¯åŠ¨å®šæ—¶å™¨

2. **æ¥æ”¶æµç¨‹**ï¼š
   - æ¥æ”¶æ•°æ®åŒ…
   - è§£æåºåˆ—å·
   - æ£€æµ‹é‡å¤å’Œä¹±åº
   - å‘é€ACK
   - å¤„ç†æ•°æ®åŒ…å†…å®¹

3. **é‡ä¼ æµç¨‹**ï¼š
   - æ£€æµ‹è¶…æ—¶æ•°æ®åŒ…
   - é‡ä¼ æœªç¡®è®¤çš„æ•°æ®åŒ…
   - è¾¾åˆ°æœ€å¤§é‡ä¼ æ¬¡æ•°æ—¶æ”¾å¼ƒ

4. **æµé‡æ§åˆ¶æµç¨‹**ï¼š
   - åŸºäºçª—å£å¤§å°æ§åˆ¶å‘é€é€Ÿç‡
   - æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´çª—å£å¤§å°
   - é¿å…å‘é€è¿‡å¤šæ•°æ®å¯¼è‡´ç½‘ç»œæ‹¥å¡

### 5. çŸ¥è¯†ç‚¹æ€»ç»“
**æ ¸å¿ƒæ¦‚å¿µ**ï¼š
- UDPçš„æ— è¿æ¥ç‰¹æ€§ï¼šUDPæ˜¯æ— è¿æ¥çš„ï¼Œä¸æä¾›å¯é æ€§ä¿éšœ
- å¯é æ€§å¢å¼ºæœºåˆ¶ï¼šåºåˆ—å·ã€ç¡®è®¤ã€é‡ä¼ ã€æµé‡æ§åˆ¶ç­‰
- å®æ—¶æ€§ä¸å¯é æ€§çš„æƒè¡¡ï¼šéœ€è¦åœ¨å»¶è¿Ÿå’Œå¯é æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹
- ç½‘ç»œæ‹¥å¡æ§åˆ¶ï¼šé¿å…ç½‘ç»œæ‹¥å¡å¯¼è‡´çš„æ€§èƒ½ä¸‹é™
- å·®å¼‚åŒ–æœåŠ¡ï¼šæ ¹æ®æ•°æ®é‡è¦æ€§æä¾›ä¸åŒçº§åˆ«çš„æœåŠ¡

**æŠ€æœ¯è¦ç‚¹**ï¼š
- åºåˆ—å·æœºåˆ¶çš„å®ç°å’Œç®¡ç†
- ç¡®è®¤æœºåˆ¶çš„è®¾è®¡å’Œä¼˜åŒ–
- é‡ä¼ ç­–ç•¥çš„é€‰æ‹©å’Œé…ç½®
- æµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶çš„å®ç°
- è·¨å¹³å°å…¼å®¹æ€§çš„è€ƒè™‘

**åº”ç”¨åœºæ™¯**ï¼š
- å®æ—¶å¤šäººæ¸¸æˆçš„ç©å®¶è¾“å…¥ä¼ è¾“
- è¯­éŸ³å’Œè§†é¢‘æµçš„ä¼ è¾“
- å®æ—¶ä¼ æ„Ÿå™¨æ•°æ®çš„ä¼ è¾“
- ä»»ä½•å¯¹å»¶è¿Ÿæ•æ„Ÿä½†åˆéœ€è¦ä¸€å®šå¯é æ€§çš„åœºæ™¯

**å­¦ä¹ å»ºè®®**ï¼š
- æ·±å…¥ç†è§£UDPå’ŒTCPçš„åŒºåˆ«å’Œé€‚ç”¨åœºæ™¯
- å­¦ä¹ ç½‘ç»œåè®®çš„åŸºæœ¬åŸç†
- å®è·µç¼–å†™å¯é çš„UDPä¼ è¾“ä»£ç 
- æµ‹è¯•åœ¨ä¸åŒç½‘ç»œæ¡ä»¶ä¸‹çš„æ€§èƒ½å’Œå¯é æ€§
- äº†è§£æ¸¸æˆå¼€å‘ä¸­å¸¸ç”¨çš„ç½‘ç»œåº“ï¼Œå¦‚ENetã€RakNetç­‰

**è¿›é˜¶è·¯å¾„**ï¼š
- å­¦ä¹ æ›´é«˜çº§çš„ç½‘ç»œåè®®ï¼Œå¦‚SCTPï¼ˆStream Control Transmission Protocolï¼‰
- ç ”ç©¶æ¸¸æˆç½‘ç»œåŒæ­¥æŠ€æœ¯ï¼šçŠ¶æ€åŒæ­¥å’Œå¸§åŒæ­¥
- äº†è§£ç½‘ç»œå®‰å…¨ï¼šåŠ å¯†ã€è®¤è¯ã€é˜²ä½œå¼Š
- å­¦ä¹ æœåŠ¡å™¨æ¶æ„è®¾è®¡ï¼šè´Ÿè½½å‡è¡¡ã€é›†ç¾¤ã€åˆ†å¸ƒå¼
- ç ”ç©¶è¾¹ç¼˜è®¡ç®—å’Œäº‘æ¸¸æˆæŠ€æœ¯

### 6. é¡¹ç›®å®è·µ
**é¡¹ç›®æ¡ˆä¾‹**ï¼š
- **ç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆ**ï¼šä½¿ç”¨å¯é UDPä¼ è¾“ç©å®¶è¾“å…¥å’Œæ¸¸æˆçŠ¶æ€
- **å¤šäººåœ¨çº¿æˆ˜æ–— arena**ï¼šä½¿ç”¨å·®å¼‚åŒ–å¯é æ€§ä¼ è¾“ä¸åŒç±»å‹çš„æ•°æ®
- **å®æ—¶æˆ˜ç•¥æ¸¸æˆ**ï¼šä½¿ç”¨å¯é UDPä¼ è¾“å‘½ä»¤å’ŒçŠ¶æ€æ›´æ–°
- **è¯­éŸ³èŠå¤©ç³»ç»Ÿ**ï¼šä½¿ç”¨UDPä¼ è¾“è¯­éŸ³æ•°æ®ï¼Œç»“åˆå¯é æ€§æœºåˆ¶

**å¼€å‘æµç¨‹**ï¼š
1. **éœ€æ±‚åˆ†æ**ï¼šç¡®å®šç½‘ç»œé€šä¿¡çš„å…·ä½“éœ€æ±‚å’Œåœºæ™¯
2. **æŠ€æœ¯é€‰å‹**ï¼šé€‰æ‹©åˆé€‚çš„ç½‘ç»œåº“æˆ–è‡ªè¡Œå®ç°
3. **åè®®è®¾è®¡**ï¼šè®¾è®¡æ•°æ®åŒ…æ ¼å¼å’Œå¯é æ€§ç­–ç•¥
4. **å®ç°åŸå‹**ï¼šç¼–å†™åŸºæœ¬çš„ç½‘ç»œé€šä¿¡ä»£ç 
5. **æµ‹è¯•éªŒè¯**ï¼šåœ¨ä¸åŒç½‘ç»œæ¡ä»¶ä¸‹æµ‹è¯•å¯é æ€§å’Œæ€§èƒ½
6. **ä¼˜åŒ–è°ƒæ•´**ï¼šæ ¹æ®æµ‹è¯•ç»“æœä¼˜åŒ–å‚æ•°å’Œå®ç°
7. **é›†æˆä¸Šçº¿**ï¼šå°†ç½‘ç»œç³»ç»Ÿé›†æˆåˆ°æ¸¸æˆä¸­å¹¶å‘å¸ƒ

**æœ€ä½³å®è·µ**ï¼š
- **å·®å¼‚åŒ–å¯é æ€§**ï¼šå¯¹ä¸åŒç±»å‹çš„æ•°æ®é‡‡ç”¨ä¸åŒçš„å¯é æ€§ç­–ç•¥
- **é¢„æµ‹å’Œæ’å€¼**ï¼šä½¿ç”¨é¢„æµ‹å’Œæ’å€¼æŠ€æœ¯å‡å°‘å»¶è¿Ÿå½±å“
- **å¸¦å®½ä¼˜åŒ–**ï¼šä½¿ç”¨æ•°æ®å‹ç¼©ã€å¢é‡æ›´æ–°ç­‰æŠ€æœ¯å‡å°‘å¸¦å®½ä½¿ç”¨
- **é”™è¯¯å¤„ç†**ï¼šå®ç°å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®š
- **ç›‘æ§å’Œåˆ†æ**ï¼šç›‘æ§ç½‘ç»œæ€§èƒ½ï¼Œåˆ†æå’Œè§£å†³é—®é¢˜

### 7. ç½‘ç»œæœç´¢ç»“æœ
**ç›¸å…³èµ„æ–™**ï¼š
- æ¸¸æˆç½‘ç»œç¼–ç¨‹ç²¾è¦ - Glenn Fiedler
- UDPåè®®è¯¦è§£ - RFC 768
- ENetç½‘ç»œåº“æ–‡æ¡£
- RakNetç½‘ç»œåº“æ–‡æ¡£
- å®æ—¶å¤šäººæ¸¸æˆç½‘ç»œç¼–ç¨‹ - Gabriel Gambetta

**ä¿¡æ¯éªŒè¯**ï¼š
- UDPå¯é æ€§å¢å¼ºæœºåˆ¶çš„å®ç°æ–¹æ³•å·²åœ¨å¤šä¸ªæƒå¨æ¥æºä¸­å¾—åˆ°éªŒè¯
- ä»£ç ç¤ºä¾‹åŸºäºæ¸¸æˆå¼€å‘å®è·µå’Œç½‘ç»œç¼–ç¨‹æœ€ä½³å®è·µ
- ä¼˜åŒ–å»ºè®®æ¥è‡ªæ¸¸æˆå¼€å‘ç¤¾åŒºçš„ç»éªŒ

**æƒå¨æ¥æº**ï¼š
- IETF RFC 768ï¼šUser Datagram Protocol
- ENetç½‘ç»œåº“ï¼šhttps://github.com/lsalzman/enet
- RakNetç½‘ç»œåº“ï¼šhttps://github.com/OculusVR/RakNet
- Glenn Fiedlerçš„ç½‘ç»œç¼–ç¨‹æ–‡ç« ï¼šhttps://gafferongames.com/
