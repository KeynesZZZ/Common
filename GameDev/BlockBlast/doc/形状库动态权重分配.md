# 基于"形状库"的动态权重分配

游戏会将方块分为三个等级，根据游戏进程实时调整其出现的概率（Weight）：

| 等级 | 代表形状 | 正常权重 | 压力测试权重 (高分/空间小时) |
|------|----------|----------|------------------------------|
| 基础型 (Easy) | $1 \times 1$, $1 \times 2$, $2 \times 2$ | 40% | 15% (让你极难补位) |
| 功能型 (Normal) | $1 \times 3$, $L$型, $Z$型 | 40% | 35% |
| 压力型 (Hard) | $3 \times 3$, $5 \times 1$, 巨型$L$ | 20% | 50% (逼你走投无路) |

---

在《Block Blast!》中，**动态权重分配（Dynamic Weight Allocation）**是"发牌员"的指挥棒。它不仅看你的棋盘能不能放下（影子模拟），更会根据你的当前表现，人为地改变不同方块出现的"概率分布"。这套系统的核心逻辑是：建立一个分级形状库，并根据"难度因子"动态修改每类形状的抽奖概率。

## 1. 形状库的分级 (The Shape Library Grading)

系统通常将方块按"对棋盘的威胁程度"分为三个等级：

### 一级：基础补位块（Low Threat）

- **如**：$1 \times 1$, $1 \times 2$, $2 \times 2$
- **特点**：极难卡死玩家，通常用于"续命"或调整布局。

### 二级：功能干扰块（Medium Threat）

- **如**：$L$型、$T$型、中等长度的长条（$1 \times 3$）
- **特点**：需要一定的规划才能完美嵌入，是构成游戏日常难度的核心。

### 三级：处决/大空间块（High Threat）

- **如**：$3 \times 3$ 巨型方阵、$5 \times 1$ 特长条、$3 \times 3$ 的大 $L$ 型
- **特点**：空间杀手。如果棋盘碎片化严重，给出一块即宣告游戏结束。

## 2. C# 实现：动态权重管理器

这个算法的核心在于 `CalculateProbability` 函数，它通过一个"难度系数"来扭曲概率分布。

```csharp
public class WeightDistributor
{
    // 定义形状等级
    public enum ShapeGrade { Basic, Functional, Executioner }

    // 形状与其基础权重
    private Dictionary<ShapeGrade, float> baseWeights = new Dictionary<ShapeGrade, float> {
        { ShapeGrade.Basic, 40f },      // 基础块默认 40%
        { ShapeGrade.Functional, 40f }, // 功能块默认 40%
        { ShapeGrade.Executioner, 20f } // 巨型块默认 20%
    };

    /// <summary>
    /// 根据游戏状态动态获取当前权重分布
    /// </summary>
    public Dictionary<ShapeGrade, float> GetDynamicWeights(int score, float fillRate, int comboCount)
    {
        var dynamicWeights = new Dictionary<ShapeGrade, float>(baseWeights);    

        // 核心规则 1：连击惩罚逻辑 (Combo Penalty)
        // 连击越高，系统越倾向于给你"大块"来终结你的连击
        if (comboCount > 10)
        {
            dynamicWeights[ShapeGrade.Executioner] += 15f;
            dynamicWeights[ShapeGrade.Basic] -= 15f;
        }

        // 规则 2：高分收割逻辑 (High Score Harvesting)
        if (score > 10000)
        {
            // 分数越高，基础块（小块）的概率越低，让你极难修补碎洞
            dynamicWeights[ShapeGrade.Basic] *= 0.5f;
            dynamicWeights[ShapeGrade.Executioner] *= 2.0f;
        }

        // 规则 3：绝地求生宽容 (Deathbed Mercy)
        if (fillRate > 0.9f)
        {
            // 棋盘快满时，为了不让玩家立刻挫败，临时提升小块权重
            dynamicWeights[ShapeGrade.Executioner] = 5f;
        }

        return NormalizeWeights(dynamicWeights);
    }

    // 归一化处理，确保概率总和为 100%
    private Dictionary<ShapeGrade, float> NormalizeWeights(Dictionary<ShapeGrade, float> weights)
    {
        float total = weights.Values.Sum();
        return weights.ToDictionary(k => k.Key, v => (v.Value / total) * 100f); 
    }
}
```

## 3. 算法背后的"心理博弈"

### 概率的"非对称性"

你可能会觉得："我留了一个长条的位置，为什么一直不给长条？"

这是因为系统一旦检测到你有特定的长条槽（Pattern Detection），它会把该形状从 Functional 等级临时打入"冷宫"，甚至降权到 $1\%$。它在赌你会失去耐心，用其他方块把这个槽位填碎。

### "喂药"机制

当系统连续给了你几个 Executioner（巨型块）把你逼到绝路后，它会突然给出一组全都是 Basic（基础小块）的牌。这在算法上叫 **"难度回撤"**。

这种"先打你一巴掌再给你个甜枣"的策略，会让你产生"我通过操作逆天改命"的快感，极大增强游戏的成瘾性。

## 4. 如何"反制"权重分配？

了解这个算法后，你可以采取以下反制手段：

- **拒绝"等长条"**：只要你棋盘上没有明显的长条槽，长条作为 Functional 块出现的概率反而更高。
- **主动消耗"碎片化"**：系统喜欢在空间大时塞大块。如果你主动把大块空间利用得比较紧凑，系统检测到 Executioner 块无法放置（通过影子模拟），它会被迫退而求其次给你小块。
- **断连策略**：如果感觉发牌已经变得极度恶意，主动中断连击（Combo）。系统可能会判定你进入了"弱势状态"，从而降低难度系数。

---

你想知道系统是如何通过"模式识别"来发现你正在预留特定形状（比如等一个 T 型或 L 型）的吗？我们可以拆解它的棋盘扫描算法。
