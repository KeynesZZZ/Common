# 1. 影子棋盘模拟 (Shadow Board Simulation)

当一轮（三个方块）结束，准备生成下一组时，算法会执行以下步骤：

- **候选集生成**：从方块库（包含各种 $L$ 型、长条、方块等约 20-30 种形状）中随机挑选出一组候选方块。
- **可行性扫描**：算法会对当前棋盘进行全量扫描，通过循环遍历（类似 $8 	imes 8$ 的矩阵索引）来检测候选块是否能放下。
- **强制解生成**：如果随机挑选的一组方块在当前棋盘上完全无解，算法会立即触发"修正"，强行将其中一个候选块替换为当前棋盘上最大的空洞形状（比如 $1 \times 1$ 或 $2 \times 2$），以保证游戏不至于在非高分段莫名其妙结束。

"影子棋盘模拟"是《Block Blast!》维持游戏节奏的核心。它的本质是在真实棋盘（Actual Board）之上，建立一个虚拟层（Virtual Layer）。在方块真正送到你手中之前，算法已经在虚拟层里"排练"了成百上千次。

```csharp
using System;
using System.Collections.Generic;

public class ShadowSimulator
{
    private const int Size = 8;

    // 模拟放置方块的结果
    public struct SimulationResult
    {
        public bool IsViable;      // 这组方块是否全都能放下
        public int Fragments;     // 放置后产生的碎片空间数量（数值越高，棋盘越乱）
        public int PotentialLines; // 放置后能消除的行数
    }

    /// <summary>
    /// 核心方法：模拟投放一组方块
    /// </summary>
    /// <param name="currentBoard">当前真实棋盘状态</param>
    /// <param name="candidateSet">系统拟定发给玩家的三个方块</param>
    public SimulationResult EvaluateSet(int[,] currentBoard, List<int[,]> candidateSet)
    {
        // 1. 克隆一个"影子棋盘"，避免影响真实游戏数据
        int[,] shadowBoard = (int[,])currentBoard.Clone();
        
        bool allPlaced = true;
        int totalCleared = 0;

        // 2. 按顺序模拟投放
        foreach (var block in candidateSet)
        {
            // 寻找影子棋盘上的最佳/可用放置点
            var pos = FindBestPlacement(shadowBoard, block);
            
            if (pos != null)
            {
                // 在影子棋盘上模拟"落子"并计算消除
                totalCleared += ApplyPlacement(shadowBoard, block, pos.Value.Item1, pos.Value.Item2);
            }
            else
            {
                allPlaced = false; // 只要有一个放不下，这一组就是"死局"候选
                break;
            }
        }

        // 3. 评估棋盘质量：计算连通区域（碎片化程度）
        int fragments = CalculateFragmentation(shadowBoard);

        return new SimulationResult
        {
            IsViable = allPlaced,
            Fragments = fragments,
            PotentialLines = totalCleared
        };
    }

    // 影子棋盘上的碰撞检测
    private bool CanPlace(int[,] board, int[,] block, int row, int col)
    {
        int bRows = block.GetLength(0);
        int bCols = block.GetLength(1);

        for (int r = 0; r < bRows; r++)
        {
            for (int c = 0; c < bCols; c++)
            {
                if (block[r, c] == 1)
                {
                    int targetR = row + r;
                    int targetC = col + c;

                    // 越界或重叠
                    if (targetR >= Size || targetC >= Size || board[targetR, targetC] == 1)
                        return false;
                }
            }
        }
        return true;
    }

    // 影子棋盘的更新：模拟消行
    private int ApplyPlacement(int[,] board, int[,] block, int row, int col)
    {
        // 放置方块
        for (int r = 0; r < block.GetLength(0); r++)
            for (int c = 0; c < block.GetLength(1); c++)
                if (block[r, c] == 1) board[row + r, col + c] = 1;

        // 影子消除逻辑（模拟真实消除）
        return MockClearLines(board);
    }

    // 计算碎片化程度（使用简单的洪水填充算法 Flood Fill）
    private int CalculateFragmentation(int[,] board)
    {
        bool[,] visited = new bool[Size, Size];
        int regionCount = 0;

        for (int i = 0; i < Size; i++)
        {
            for (int j = 0; j < Size; j++)
            {
                if (board[i, j] == 0 && !visited[i, j])
                {
                    regionCount++; // 发现一个独立的空闲区域
                    FloodFill(board, visited, i, j);
                }
            }
        }
        return regionCount; // 区域越多，意味着大块方块越难放下
    }

    private void FloodFill(int[,] board, bool[,] visited, int r, int c) { /* ...标准递归实现... */ }
    
    private (int, int)? FindBestPlacement(int[,] board, int[,] block)
    {
        // 影子算法会遍历 8x8 所有坐标，返回第一个能放下的点
        for (int i = 0; i < Size; i++)
            for (int j = 0; j < Size; j++)
                if (CanPlace(board, block, i, j)) return (i, j);
        return null;
    }
}
```

---

## 该算法在《Block Blast!》中的具体应用规则

### 1. 自动避开"死局" (低分保护)

在玩家分段较低时，生成器会调用 `EvaluateSet`。如果返回的 `IsViable` 为 `false`，后台会立即废弃这组方块，重新生成，直到找到一组能让玩家活下去的方块。

### 2. 制造"混乱感" (碎片化评估)

注意代码中的 `CalculateFragmentation`（碎片化评估）。如果系统想增加难度，它会从多个 `IsViable` 的候选组中，挑选出那个 `Fragments` 数值最高的组合。

**现象**：虽然你现在能放下这三个块，但放完之后，棋盘上的空位会被切得七零八落，没有任何一块空地能放下 $3 \times 3$。

### 3. 动态控制消除节奏

如果 `PotentialLines`（潜在消除行数）过高，且你正处于连击中，高分段系统可能会调低这组方块的出现概率，以防你一次性消除太多行获得巨额加分。
